<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è…¦åŠ›å¤§äº‚é¬¥ï¼šé›™äººå¥§æ•¸ç«¶æŠ€å ´</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Noto+Sans+TC:wght@700&display=swap');

        body {
            margin: 0;
            padding: 0;
            background-color: #2c3e50;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            font-family: 'Noto Sans TC', sans-serif;
            color: white;
            user-select: none;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 30px rgba(0,0,0,0.6);
            border: 4px solid #f1c40f;
            border-radius: 8px;
            background-color: #34495e;
        }

        canvas {
            display: block;
        }

        .mobile-warning {
            display: none;
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            color: white;
            z-index: 999;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 20px;
            font-size: 1.2rem;
        }

        @media (hover: none) and (pointer: coarse) {
            .mobile-warning { display: flex; }
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div class="mobile-warning">è«‹ä½¿ç”¨é›»è…¦éµç›¤é€²è¡Œé›™äººå°æˆ°ä»¥ç²å¾—æœ€ä½³é«”é©—ã€‚</div>
</div>

<script>
/**
 * è…¦åŠ›å¤§äº‚é¬¥ v4.0 (Final Fix)
 * ä¿®æ­£ï¼šå¥ªå¯¶æ¶å¥ªåˆ¤å®šã€ç­”æ¡ˆç”Ÿæˆé‚è¼¯ã€å¼“ç®­è¦–è¦ºã€æ’è¡Œæ¦œä½ç½®
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// --- å…¨å±€è®Šæ•¸ ---
const GAME_WIDTH = 800;
const GAME_HEIGHT = 600;

const STATE = {
    MENU: 0,
    INSTRUCTION: 1,
    PLAYING: 2,
    ROUND_END: 3,
    GAME_OVER: 4
};

let currentState = STATE.MENU;
let frameCount = 0;
let totalTime = 60;
let timeRemaining = 0;

// ç©å®¶é…ç½®
const p1 = { score: 0, color: '#3498db', name: 'Player 1', emoji: 'ğŸ¤–', lastKey: null, lastKeyTime: 0, dash: false, stun: 0 };
const p2 = { score: 0, color: '#e74c3c', name: 'Player 2', emoji: 'ğŸ¦–', lastKey: null, lastKeyTime: 0, dash: false, stun: 0 };

const keys = {};
let currentMode = null;
let roundWinner = null;
let roundInstruction = "";

// é—œå¡æ± 
let modeDeck = []; 

const LEADERBOARD_KEY = 'math_battle_ranking_v4';

// --- å·¥å…·å‡½æ•¸ ---

function randomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

function rectIntersect(x1, y1, w1, h1, x2, y2, w2, h2) {
    return x2 < x1 + w1 && x2 + w2 > x1 && y2 < y1 + h1 && y2 + h2 > y1;
}

function circleIntersect(x1, y1, r1, x2, y2, r2) {
    let dist = Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2);
    return dist < r1 + r2;
}

function drawEmoji(emoji, x, y, size) {
    ctx.font = `${size}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(emoji, x, y);
}

// --- è¼¸å…¥è™•ç† ---
window.addEventListener('keydown', (e) => {
    if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight", "Space"].indexOf(e.code) > -1) {
        e.preventDefault();
    }
    const key = e.key.toLowerCase();
    const now = Date.now();
    let player = null;

    if (['w','a','s','d'].includes(key)) player = p1;
    if (['arrowup','arrowdown','arrowleft','arrowright'].includes(key)) player = p2;

    if (player && player.stun <= 0) {
        // é›™æ“Šæª¢æ¸¬ (è¡åˆº)
        if (player.lastKey === key && now - player.lastKeyTime < 300) {
            player.dash = true; 
            // è¡åˆºç‹€æ…‹æŒçºŒä¸€æ®µæ™‚é–“ï¼Œä¸ç”±æŒ‰éµæ”¾é–‹æ±ºå®š
            setTimeout(() => player.dash = false, 500); 
        }
        player.lastKey = key;
        player.lastKeyTime = now;
    }

    keys[key] = true;
});

window.addEventListener('keyup', (e) => {
    const key = e.key.toLowerCase();
    keys[key] = false;
    // æ³¨æ„ï¼šé€™è£¡ä¸å–æ¶ˆ dashï¼Œè®“ dash ç”±æ™‚é–“æ§åˆ¶ï¼Œæ–¹ä¾¿æ¶å¥ªåˆ¤å®š
});

// --- é¡Œç›®ç”Ÿæˆå™¨ ---
function generateProblem(forceType = -1) {
    const difficulty = Math.min(1, (60 - totalTime) / 50); 
    
    // 0:åŠ æ¸›, 1:ä¹˜æ³•, 2:æ•¸åˆ—
    let type;
    if (forceType !== -1) {
        type = forceType;
    } else {
        let r = Math.random();
        if (difficulty < 0.3) {
            type = (r > 0.6) ? 1 : 0; 
        } else if (difficulty < 0.6) {
            type = (r > 0.4) ? 1 : (r > 0.8 ? 2 : 0);
        } else {
            type = (r > 0.5) ? 2 : 1;
        }
    }

    let q = "", a = 0, options = [];

    if (type === 0) { // åŠ æ¸›
        let max = 10 + Math.floor(difficulty * 40);
        let n1 = randomInt(1, max);
        let n2 = randomInt(1, max);
        if (Math.random() > 0.5) {
            q = `${n1} + ${n2} = ?`;
            a = n1 + n2;
        } else {
            let big = Math.max(n1, n2);
            let small = Math.min(n1, n2);
            q = `${big} - ${small} = ?`;
            a = big - small;
        }
    } else if (type === 1) { // ä¹˜æ³•
        let maxMulti = 3 + Math.floor(difficulty * 8); 
        let n1 = randomInt(2, maxMulti);
        let n2 = randomInt(2, maxMulti);
        q = `${n1} Ã— ${n2} = ?`;
        a = n1 * n2;
    } else { // æ•¸åˆ—
        let start = randomInt(1, 10);
        let step = randomInt(2, 5);
        let idx = randomInt(2, 4); 
        let seq = [];
        for(let i=0; i<5; i++) seq.push(start + i*step);
        a = seq[idx];
        seq[idx] = '?';
        q = seq.join(', ');
    }

    // ç”Ÿæˆé¸é … (ç¢ºä¿æœ‰æ­£ç¢ºç­”æ¡ˆ)
    // å…ˆç”Ÿæˆå¹¾å€‹éŒ¯èª¤çš„
    while(options.length < 3) {
        let offset = randomInt(-5, 5);
        if (offset === 0) continue;
        let wrong = a + offset;
        if (wrong < 0) wrong = Math.abs(wrong);
        if (wrong !== a && !options.includes(wrong)) options.push(wrong);
    }
    // å°‡æ­£ç¢ºç­”æ¡ˆåŠ å…¥ï¼Œç„¶å¾Œåœ¨æ¨¡å¼ä¸­æˆ‘å€‘æœƒå†è™•ç†é¡¯ç¤º
    options.push(a); 
    // é€™å€‹ options é™£åˆ—åŒ…å« 4 å€‹å…ƒç´  (3éŒ¯1å°)ï¼Œä½†æœ‰äº›æ¨¡å¼åªç”¨ 3 å€‹
    
    // ç‚ºäº†å®‰å…¨ï¼Œé€™è£¡å…ˆæ‰“äº‚
    options.sort(() => Math.random() - 0.5);

    return { text: q, answer: a, options: options };
}

// --- éŠæˆ²æ¨¡å¼é¡åˆ¥ ---
class GameMode {
    constructor() {
        this.winner = null;
        this.problem = generateProblem();
    }
    init() {}
    update() {}
    draw() {}
    checkWin(player) {
        if (!this.winner) {
            this.winner = player;
            player.score += 100;
            setTimeout(() => { if (currentState === STATE.PLAYING) endGameRound(player); }, 500); 
        } else if (this.winner !== player) {
             player.score += 50;
        }
    }
    
    drawOptionText(val, x, y, keyHint) {
        ctx.beginPath();
        ctx.arc(x, y, 35, 0, Math.PI*2);
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fill();
        ctx.lineWidth = 4;
        ctx.strokeStyle = '#f1c40f'; 
        ctx.stroke();

        ctx.fillStyle = 'white'; 
        ctx.font = 'bold 30px Arial'; 
        ctx.textAlign = 'center'; 
        ctx.textBaseline = 'middle';
        ctx.fillText(val, x, y + 2); 

        ctx.fillStyle = '#bdc3c7'; 
        ctx.font = '14px Arial'; 
        ctx.fillText(keyHint, x, y + 55);
    }
}

// Mode 1: å¼“ç®­å°„æ“Š (Shooter Mode - Bow & Arrow)
class ShooterMode extends GameMode {
    constructor() {
        super();
        this.bullets = [];
        this.targets = []; 
        this.p1Angle = 0; this.p2Angle = 0;
        this.p1Cooldown = 0; this.p2Cooldown = 0;
        this.bowRadius = 40; 
    }

    init() {
        // å–å‰4å€‹é¸é …(å«æ­£ç¢ºç­”æ¡ˆ)ä½œç‚ºç›®æ¨™
        let pool = this.problem.options.slice(0, 4);
        // ç¢ºä¿è£¡é¢æœ‰ç­”æ¡ˆ (generateProblem è¿”å›çš„ options å·²ç¶“åŒ…å«ç­”æ¡ˆ)
        
        pool.forEach(opt => {
            this.targets.push({
                x: randomInt(100, 700), y: randomInt(50, 250),
                vx: (Math.random() - 0.5) * 4, vy: (Math.random() - 0.5) * 4,
                val: opt, r: 25,
                type: opt === this.problem.answer ? 'correct' : 'wrong'
            });
        });
        this.walls = [{x: 350, y: 300, w: 100, h: 20}, {x: 100, y: 150, w: 20, h: 100}, {x: 680, y: 150, w: 20, h: 100}];
    }

    update() {
        // P1 Control
        if (keys['a']) this.p1Angle -= 0.05;
        if (keys['d']) this.p1Angle += 0.05;
        this.p1Angle = Math.max(-1.2, Math.min(1.2, this.p1Angle));
        
        if (keys['w'] && this.p1Cooldown <= 0) {
            // å¾å¼“çš„ä¸­å¿ƒç™¼å°„
            let startX = 100 + Math.sin(this.p1Angle) * 20;
            let startY = 550 - Math.cos(this.p1Angle) * 20;
            this.bullets.push({
                x: startX, y: startY, 
                vx: Math.sin(this.p1Angle)*15, vy: -Math.cos(this.p1Angle)*15, 
                angle: this.p1Angle,
                owner: p1, life: 100
            });
            this.p1Cooldown = 30; // å°„ç®­é–“éš”ç¨é•·
        }

        // P2 Control
        if (keys['arrowleft']) this.p2Angle -= 0.05;
        if (keys['arrowright']) this.p2Angle += 0.05;
        this.p2Angle = Math.max(-1.2, Math.min(1.2, this.p2Angle));
        
        if (keys['arrowup'] && this.p2Cooldown <= 0) {
            let startX = 700 + Math.sin(this.p2Angle) * 20;
            let startY = 550 - Math.cos(this.p2Angle) * 20;
            this.bullets.push({
                x: startX, y: startY, 
                vx: Math.sin(this.p2Angle)*15, vy: -Math.cos(this.p2Angle)*15, 
                angle: this.p2Angle,
                owner: p2, life: 100
            });
            this.p2Cooldown = 30;
        }

        if (this.p1Cooldown > 0) this.p1Cooldown--;
        if (this.p2Cooldown > 0) this.p2Cooldown--;

        // Targets
        this.targets.forEach(t => {
            t.x += t.vx; t.y += t.vy;
            if (t.x < t.r || t.x > GAME_WIDTH - t.r) t.vx *= -1;
            if (t.y < t.r || t.y > 400) t.vy *= -1;
        });

        // Arrows (Bullets)
        for (let i = this.bullets.length - 1; i >= 0; i--) {
            let b = this.bullets[i];
            b.x += b.vx; b.y += b.vy; b.life--;
            if (b.x < 0 || b.x > GAME_WIDTH) b.vx *= -1;
            if (b.y < 0) b.vy *= -1; 
            this.walls.forEach(w => { if (rectIntersect(b.x, b.y, 5, 5, w.x, w.y, w.w, w.h)) b.vy *= -1; });

            for (let t of this.targets) {
                if (circleIntersect(b.x, b.y, 5, t.x, t.y, t.r)) {
                    if (t.type === 'correct') this.checkWin(b.owner);
                    else b.life = 0; 
                    this.bullets.splice(i, 1);
                    break;
                }
            }
            if (b.life <= 0 || b.y > 600) this.bullets.splice(i, 1);
        }
    }

    draw() {
        ctx.fillStyle = 'white';
        ctx.font = '30px Noto Sans TC';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'alphabetic';
        ctx.fillText(`å°„æ“Šæ­£ç¢ºç­”æ¡ˆ: ${this.problem.text}`, GAME_WIDTH/2, 50);

        this.targets.forEach(t => {
            ctx.fillStyle = '#ecf0f1';
            ctx.beginPath(); ctx.arc(t.x, t.y, t.r, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#2c3e50'; ctx.font = 'bold 20px Arial'; ctx.textBaseline = 'middle'; ctx.fillText(t.val, t.x, t.y);
        });

        ctx.fillStyle = '#7f8c8d';
        this.walls.forEach(w => { ctx.fillRect(w.x, w.y, w.w, w.h); drawEmoji('ğŸ§±', w.x + w.w/2, w.y + w.h/2, 20); });

        // Draw Bows
        const drawBow = (x, angle, color, emoji) => {
            ctx.save(); 
            ctx.translate(x, 550); 
            ctx.rotate(angle);
            
            // å¼“è‡‚ (å¼§ç·š)
            ctx.beginPath();
            ctx.arc(0, 10, 40, Math.PI, 0); // åŠåœ“
            ctx.lineWidth = 5;
            ctx.strokeStyle = '#d35400'; // æœ¨é ­è‰²
            ctx.stroke();

            // å¼“å¼¦
            ctx.beginPath();
            ctx.moveTo(-40, 10);
            ctx.lineTo(40, 10);
            ctx.lineWidth = 1;
            ctx.strokeStyle = '#ecf0f1';
            ctx.stroke();

            ctx.restore();
            // è§’è‰²
            drawEmoji(emoji, x, 580, 25);
        };
        drawBow(100, this.p1Angle, p1.color, p1.emoji);
        drawBow(700, this.p2Angle, p2.color, p2.emoji);

        // Draw Arrows
        this.bullets.forEach(b => {
            ctx.save();
            ctx.translate(b.x, b.y);
            ctx.rotate(b.angle);
            
            // ç®­èº«
            ctx.beginPath();
            ctx.moveTo(0, 10);
            ctx.lineTo(0, -10);
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#f1c40f';
            ctx.stroke();
            
            // ç®­é ­
            ctx.beginPath();
            ctx.moveTo(0, -15);
            ctx.lineTo(-5, -5);
            ctx.lineTo(5, -5);
            ctx.closePath();
            ctx.fillStyle = '#e74c3c';
            ctx.fill();

            // ç®­ç¾½
            ctx.beginPath();
            ctx.moveTo(0, 10);
            ctx.lineTo(-4, 15);
            ctx.moveTo(0, 10);
            ctx.lineTo(4, 15);
            ctx.stroke();

            ctx.restore();
        });
    }
}

// Mode 2: æ•¸å¹¾ä½•åœ–å½¢ (< 9)
class GeometryMode extends GameMode {
    constructor() {
        super();
        this.problem.text = "åœ–ä¸­å…±æœ‰å¤šå°‘å€‹ä¸‰è§’å½¢ï¼Ÿ";
        
        let segments, layers, count;
        // åš´æ ¼é™åˆ¶ç¸½æ•¸ <= 9
        do {
            segments = randomInt(2, 3); 
            layers = randomInt(1, 2);   
            count = (segments * (segments + 1) / 2) * layers;
        } while (count > 9);

        this.problem.answer = count;
        this.structure = { segments: segments, layers: layers };

        // é¸é …
        this.options = { 'Up': 0, 'Down': 0, 'Left': 0, 'Right': 0 };
        let keys = Object.keys(this.options);
        let correctKey = keys[randomInt(0, 3)];
        
        keys.forEach(k => {
            if (k === correctKey) this.options[k] = count;
            else {
                let n = count + randomInt(-2, 2);
                while (n === count || n <= 0) n = count + randomInt(-3, 3);
                this.options[k] = n;
            }
        });
    }

    update() {
        if (keys['w']) this.checkAnswer(p1, 'Up');
        else if (keys['s']) this.checkAnswer(p1, 'Down');
        else if (keys['a']) this.checkAnswer(p1, 'Left');
        else if (keys['d']) this.checkAnswer(p1, 'Right');

        if (keys['arrowup']) this.checkAnswer(p2, 'Up');
        else if (keys['arrowdown']) this.checkAnswer(p2, 'Down');
        else if (keys['arrowleft']) this.checkAnswer(p2, 'Left');
        else if (keys['arrowright']) this.checkAnswer(p2, 'Right');
    }

    checkAnswer(player, dir) {
        if (this.winner === player) return;
        if (player.lock) return;

        if (this.options[dir] === this.problem.answer) {
            this.checkWin(player);
        } else {
            player.score = Math.max(0, player.score - 10);
            player.lock = true;
            setTimeout(() => player.lock = false, 500);
        }
    }

    draw() {
        ctx.fillStyle = 'white';
        ctx.font = '30px Noto Sans TC';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'alphabetic';
        ctx.fillText(this.problem.text, GAME_WIDTH/2, 60);

        const topX = GAME_WIDTH / 2;
        const topY = 150;
        const baseY = 450;
        const baseWidth = 300;
        const leftX = topX - baseWidth / 2;
        const rightX = topX + baseWidth / 2;

        ctx.strokeStyle = '#f1c40f';
        ctx.lineWidth = 5;
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';

        // ç•«ä¸‰è§’å½¢
        ctx.beginPath();
        ctx.moveTo(topX, topY);
        ctx.lineTo(leftX, baseY);
        ctx.lineTo(rightX, baseY);
        ctx.closePath();
        ctx.stroke();

        let segs = this.structure.segments;
        for (let i = 1; i < segs; i++) {
            let ratio = i / segs;
            let targetX = leftX + (baseWidth * ratio);
            ctx.beginPath();
            ctx.moveTo(topX, topY);
            ctx.lineTo(targetX, baseY);
            ctx.stroke();
        }

        let lays = this.structure.layers;
        for (let i = 1; i < lays; i++) {
            let ratio = i / lays;
            let ly = topY + (baseY - topY) * ratio;
            let lx = topX - (baseWidth / 2) * ratio;
            let rx = topX + (baseWidth / 2) * ratio;
            ctx.beginPath();
            ctx.moveTo(lx, ly);
            ctx.lineTo(rx, ly);
            ctx.stroke();
        }

        this.drawOptionText(this.options.Up, GAME_WIDTH/2, 110, 'â†‘ W');
        this.drawOptionText(this.options.Down, GAME_WIDTH/2, 550, 'â†“ S');
        this.drawOptionText(this.options.Left, 100, 300, 'â† A');
        this.drawOptionText(this.options.Right, 700, 300, 'â†’ D');
    }
}

// Mode 3: æ•¸ç©æœ¨
class CubeMode extends GeometryMode {
    constructor() {
        super();
        this.problem.text = "æ•¸æ•¸æœ‰å¤šå°‘å€‹ç©æœ¨ï¼Ÿ";
        this.cubes = [];
        
        let totalCubes = 0;
        let attempts = 0;

        while (true) {
            this.cubes = [];
            totalCubes = 0;
            for(let x=0; x<3; x++) {
                for(let y=0; y<3; y++) {
                    let h = randomInt(0, 3);
                    if(x===1 && y===1 && h===0) h=1; 
                    for(let z=0; z<h; z++) {
                        this.cubes.push({gx: x, gy: y, gz: z});
                    }
                    totalCubes += h;
                }
            }
            if (totalCubes > 1 && totalCubes <= 15) break; 
            attempts++;
            if (attempts > 100) break;
        }
        
        this.problem.answer = totalCubes;
        
        this.options = { 'Up': 0, 'Down': 0, 'Left': 0, 'Right': 0 };
        let keys = Object.keys(this.options);
        let correctKey = keys[randomInt(0, 3)];
        keys.forEach(k => {
            if (k === correctKey) this.options[k] = totalCubes;
            else {
                let n = totalCubes + randomInt(-3, 3);
                while (n === totalCubes || n <= 0) n = totalCubes + randomInt(-4, 4);
                this.options[k] = n;
            }
        });
    }

    draw() {
        ctx.fillStyle = 'white';
        ctx.font = '30px Noto Sans TC';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'alphabetic';
        ctx.fillText(this.problem.text, GAME_WIDTH/2, 60);

        let originX = GAME_WIDTH / 2;
        let originY = 280;
        let size = 50;

        this.cubes.sort((a, b) => {
            let depthA = a.gx + a.gy;
            let depthB = b.gx + b.gy;
            if (depthA !== depthB) return depthA - depthB;
            return a.gz - b.gz;
        });

        this.cubes.forEach(c => {
            let x = (c.gx - c.gy) * size + originX;
            let y = (c.gx + c.gy) * size * 0.5 - (c.gz * size) + originY;
            this.drawCube(x, y, size);
        });

        this.drawOptionText(this.options.Up, GAME_WIDTH/2, 110, 'â†‘ W');
        this.drawOptionText(this.options.Down, GAME_WIDTH/2, 550, 'â†“ S');
        this.drawOptionText(this.options.Left, 100, 300, 'â† A');
        this.drawOptionText(this.options.Right, 700, 300, 'â†’ D');
    }

    drawCube(x, y, size) {
        ctx.lineWidth = 1;
        ctx.strokeStyle = '#2c3e50';
        // Top
        ctx.fillStyle = '#e74c3c'; ctx.beginPath();
        ctx.moveTo(x, y - size); ctx.lineTo(x + size, y - size * 1.5);
        ctx.lineTo(x, y - size * 2); ctx.lineTo(x - size, y - size * 1.5);
        ctx.fill(); ctx.stroke();
        // Right
        ctx.fillStyle = '#c0392b'; ctx.beginPath();
        ctx.moveTo(x, y - size); ctx.lineTo(x + size, y - size * 1.5);
        ctx.lineTo(x + size, y - size * 0.5); ctx.lineTo(x, y);
        ctx.fill(); ctx.stroke();
        // Left
        ctx.fillStyle = '#e67e22'; ctx.beginPath();
        ctx.moveTo(x, y - size); ctx.lineTo(x - size, y - size * 1.5);
        ctx.lineTo(x - size, y - size * 0.5); ctx.lineTo(x, y);
        ctx.fill(); ctx.stroke();
    }
}

// Mode 4: å¥ªå¯¶è¿½é€
class ChaseMode extends GameMode {
    constructor() {
        super();
        this.problem = generateProblem(); 
        this.problem.text = "ç®—å‡ºç­”æ¡ˆä¸¦æ¶å¥ªï¼" + this.problem.text;
        
        this.holder = null;
        this.holdTime = 0;
        this.targetTime = 180;
        this.stealCooldown = 0; // æ¶å¥ªå†·å»ä¿è­·
        
        this.items = [];
        
        // --- ä¿®æ­£ï¼šç¢ºä¿å ´ä¸Šæœ‰æ­£ç¢ºç­”æ¡ˆ ---
        // 1. å–å¾—æ­£ç¢ºç­”æ¡ˆ
        let correct = this.problem.answer;
        // 2. å–å¾—æ‰€æœ‰éŒ¯èª¤ç­”æ¡ˆçš„é¸é …
        let wrongOptions = this.problem.options.filter(o => o !== correct);
        // 3. å–å‡ºå…©å€‹éŒ¯èª¤ç­”æ¡ˆ
        let wrongs = wrongOptions.slice(0, 2);
        // 4. çµ„åˆå‡ºå ´æ±  [æ­£ç¢º, éŒ¯èª¤, éŒ¯èª¤]
        let pool = [correct, ...wrongs];
        // 5. å†æ¬¡æ‰“äº‚
        pool.sort(() => Math.random() - 0.5);
        
        pool.forEach((val, i) => {
            this.items.push({
                x: randomInt(100, 700),
                y: randomInt(100, 500),
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2,
                val: val,
                isCorrect: (val === correct)
            });
        });

        this.p1Pos = { x: 150, y: 300, cooldown: 0 };
        this.p2Pos = { x: 650, y: 300, cooldown: 0 };
    }

    update() {
        this.movePlayer(this.p1Pos, 'w', 's', 'a', 'd', p1);
        this.movePlayer(this.p2Pos, 'arrowup', 'arrowdown', 'arrowleft', 'arrowright', p2);

        this.items.forEach(item => {
            if (this.holder && item.isCorrect) {
                 let pos = this.holder === p1 ? this.p1Pos : this.p2Pos;
                 item.x = pos.x;
                 item.y = pos.y - 45;
            } else {
                item.x += item.vx; item.y += item.vy;
                if(item.x < 30 || item.x > GAME_WIDTH-30) item.vx *= -1;
                if(item.y < 30 || item.y > GAME_HEIGHT-30) item.vy *= -1;
            }
        });

        if (!this.holder) {
            this.checkPickUp(p1, this.p1Pos);
            this.checkPickUp(p2, this.p2Pos);
        } else {
            this.holdTime++;
            if (this.holdTime >= this.targetTime) this.checkWin(this.holder);
        }

        // æ¶å¥ªåˆ¤å®š
        this.checkSteal();
        
        if(p1.stun > 0) p1.stun--;
        if(p2.stun > 0) p2.stun--;
        if(this.stealCooldown > 0) this.stealCooldown--;
    }

    checkPickUp(player, pos) {
        if (player.stun > 0) return;
        for (let item of this.items) {
            if (circleIntersect(pos.x, pos.y, 30, item.x, item.y, 30)) {
                if (item.isCorrect) {
                    this.holder = player;
                    this.stealCooldown = 30; // å‰›æ’¿åˆ°æœ‰çŸ­æš«ä¿è­·
                } else {
                    player.stun = 60; 
                    pos.x -= item.vx * 10;
                }
            }
        }
    }

    movePlayer(pos, u, d, l, r, playerRef) {
        if (playerRef.stun > 0) return; 
        let speed = 5;
        if (this.holder === playerRef) speed = 4;
        
        // è¡åˆºæ™‚é€Ÿåº¦åŠ å€
        if (playerRef.dash) speed = 10; 
        
        if (keys[u]) pos.y -= speed;
        if (keys[d]) pos.y += speed;
        if (keys[l]) pos.x -= speed;
        if (keys[r]) pos.x += speed;
        pos.x = Math.max(30, Math.min(GAME_WIDTH - 30, pos.x));
        pos.y = Math.max(30, Math.min(GAME_HEIGHT - 30, pos.y));
    }

    // --- ä¿®æ­£ï¼šæ¶å¥ªé‚è¼¯ ---
    checkSteal() {
        if (!this.holder || this.stealCooldown > 0) return;

        // è¨ˆç®—å…©è€…è·é›¢
        let dist = Math.sqrt((this.p1Pos.x - this.p2Pos.x)**2 + (this.p1Pos.y - this.p2Pos.y)**2);
        
        // åˆ¤å®šåŠå¾‘ç¨å¾®å¯¬é¬†ä¸€é» (50)
        if (dist < 60) {
            // P1 æ¶ P2
            if (p1.dash && this.holder === p2) {
                this.holder = p1;
                this.holdTime = Math.max(0, this.holdTime - 30); // æ¶å¥ªæœƒæ‰£ä¸€é»é€²åº¦
                this.stealCooldown = 60; // 1ç§’ä¿è­·æœŸ
                // å½ˆé–‹ P2
                this.p2Pos.x += (this.p2Pos.x - this.p1Pos.x);
                this.p2Pos.y += (this.p2Pos.y - this.p1Pos.y);
            }
            // P2 æ¶ P1
            else if (p2.dash && this.holder === p1) {
                this.holder = p2;
                this.holdTime = Math.max(0, this.holdTime - 30);
                this.stealCooldown = 60;
                // å½ˆé–‹ P1
                this.p1Pos.x += (this.p1Pos.x - this.p2Pos.x);
                this.p1Pos.y += (this.p1Pos.y - this.p2Pos.y);
            }
        }
    }

    draw() {
        ctx.fillStyle = 'white';
        ctx.font = '30px Noto Sans TC';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'alphabetic';
        let probPart = this.problem.text.split("ï¼")[1] || this.problem.text;
        ctx.fillText(`ç®—å‡º ${probPart} ä¸¦æ¶å¥ªï¼`, GAME_WIDTH/2, 50);

        const drawPlayer = (p, pos) => {
            drawEmoji(p.emoji, pos.x, pos.y, 50);
            if (p.stun > 0) drawEmoji('ğŸ’«', pos.x, pos.y - 30, 30);
            if (p.dash) drawEmoji('ğŸ’¨', pos.x - 20, pos.y, 30);
            // æ¨™è¨˜æŒæœ‰è€…
            if (this.holder === p) {
                 ctx.beginPath();
                 ctx.arc(pos.x, pos.y, 35, 0, Math.PI*2);
                 ctx.strokeStyle = '#f1c40f';
                 ctx.lineWidth = 3;
                 ctx.stroke();
            }
        };
        drawPlayer(p1, this.p1Pos);
        drawPlayer(p2, this.p2Pos);

        this.items.forEach(item => {
            ctx.beginPath(); ctx.arc(item.x, item.y, 30, 0, Math.PI*2);
            ctx.fillStyle = '#f39c12'; ctx.fill();
            ctx.strokeStyle = '#ecf0f1'; ctx.lineWidth = 3; ctx.stroke();
            ctx.fillStyle = 'white'; ctx.font = 'bold 24px Arial'; ctx.textBaseline = 'middle';
            ctx.fillText(item.val, item.x, item.y);
        });

        if (this.holder) {
            ctx.fillStyle = this.holder.color;
            let w = (this.holdTime / this.targetTime) * 300;
            ctx.fillRect(GAME_WIDTH/2 - 150, 80, w, 20);
            ctx.strokeStyle = 'white'; ctx.lineWidth = 2;
            ctx.strokeRect(GAME_WIDTH/2 - 150, 80, 300, 20);
        }
    }
}

// Mode 5: æ•¸å­—é›¨
class RainMode extends GameMode {
    constructor() {
        super();
        this.items = []; this.spawnTimer = 0;
        this.p1X = 200; this.p2X = 600;
        if(this.problem.text.includes(',')) this.problem = generateProblem(0); 
    }

    update() {
        if (keys['a']) this.p1X -= 8;
        if (keys['d']) this.p1X += 8;
        if (keys['arrowleft']) this.p2X -= 8;
        if (keys['arrowright']) this.p2X += 8;

        this.p1X = Math.max(30, Math.min(GAME_WIDTH - 30, this.p1X));
        this.p2X = Math.max(30, Math.min(GAME_WIDTH - 30, this.p2X));

        this.spawnTimer++;
        if (this.spawnTimer > 40) {
            this.spawnTimer = 0;
            let r = Math.random();
            let type = 'wrong'; let val = 0;
            if (r > 0.7) { type = 'correct'; val = this.problem.answer; }
            else if (r < 0.2) { type = 'bomb'; val = ''; }
            else { val = this.problem.answer + randomInt(1, 10) * (Math.random()>0.5?1:-1); }

            this.items.push({ x: randomInt(30, GAME_WIDTH - 30), y: -30, type: type, val: val, speed: 3 + Math.random() * 3 });
        }

        for (let i = this.items.length - 1; i >= 0; i--) {
            let item = this.items[i]; item.y += item.speed;
            if (Math.abs(item.x - this.p1X) < 40 && Math.abs(item.y - 550) < 40) { this.handleCatch(p1, item, i); continue; }
            if (Math.abs(item.x - this.p2X) < 40 && Math.abs(item.y - 550) < 40) { this.handleCatch(p2, item, i); continue; }
            if (item.y > GAME_HEIGHT) this.items.splice(i, 1);
        }
    }

    handleCatch(player, item, index) {
        this.items.splice(index, 1);
        if (item.type === 'correct') this.checkWin(player);
        else if (item.type === 'bomb') player.score = Math.max(0, player.score - 50);
        else player.score = Math.max(0, player.score - 10);
    }

    draw() {
        ctx.fillStyle = 'white'; ctx.font = '30px Noto Sans TC'; ctx.textAlign = 'center'; ctx.textBaseline = 'alphabetic';
        ctx.fillText(`æ¥ä½æ­£ç¢ºç­”æ¡ˆ: ${this.problem.text}`, GAME_WIDTH/2, 50);
        drawEmoji(p1.emoji, this.p1X, 550, 60);
        drawEmoji(p2.emoji, this.p2X, 550, 60);

        this.items.forEach(item => {
            if (item.type === 'bomb') drawEmoji('ğŸ’£', item.x, item.y, 40);
            else {
                ctx.fillStyle = '#ecf0f1';
                ctx.beginPath(); ctx.arc(item.x, item.y, 25, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = 'black'; ctx.font = '20px Arial'; ctx.textBaseline = 'middle'; ctx.fillText(item.val, item.x, item.y);
            }
        });
    }
}

// --- æµç¨‹æ§åˆ¶ ---

function startNewGame() {
    p1.score = 0; p2.score = 0;
    p1.stun = 0; p2.stun = 0;
    totalTime = 60;
    modeDeck = []; 
    currentState = STATE.MENU;
}

function selectNextMode() {
    if (modeDeck.length === 0) {
        modeDeck = [0, 1, 2, 3, 4];
        for (let i = modeDeck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [modeDeck[i], modeDeck[j]] = [modeDeck[j], modeDeck[i]];
        }
    }
    
    const nextIndex = modeDeck.pop();
    const modes = [ShooterMode, GeometryMode, CubeMode, ChaseMode, RainMode];
    
    currentMode = new modes[nextIndex]();
    currentMode.init();
    
    const instructions = ["å°„æ“Šæ­£ç¢ºç­”æ¡ˆï¼", "æ•¸æ•¸ä¸‰è§’å½¢ï¼", "æ•¸æ•¸ç©æœ¨ï¼", "ç®—å‡ºç­”æ¡ˆä¸¦æ¶å¥ªï¼", "æ¥ä½æ­£ç¢ºç­”æ¡ˆï¼"];
    roundInstruction = instructions[nextIndex];
    
    currentState = STATE.INSTRUCTION;
    timeRemaining = 120; 
}

function endGameRound(winner) {
    roundWinner = winner;
    currentState = STATE.ROUND_END;
    timeRemaining = 60; 
}

function update() {
    frameCount++;
    if (currentState === STATE.MENU) {
        if (keys[' ']) { totalTime = 60; p1.score = 0; p2.score = 0; selectNextMode(); }
    } else if (currentState === STATE.INSTRUCTION) {
        timeRemaining--;
        if (timeRemaining <= 0) currentState = STATE.PLAYING;
    } else if (currentState === STATE.PLAYING) {
        if (frameCount % 60 === 0) totalTime--;
        if (totalTime <= 0) { saveScore(); currentState = STATE.GAME_OVER; }
        currentMode.update();
    } else if (currentState === STATE.ROUND_END) {
        timeRemaining--;
        if (timeRemaining <= 0) selectNextMode();
    } else if (currentState === STATE.GAME_OVER) {
        if (keys[' ']) startNewGame();
    }
}

function draw() {
    ctx.fillStyle = '#2c3e50';
    ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

    if (currentState === STATE.MENU) {
        ctx.fillStyle = 'white'; ctx.textAlign = 'center'; ctx.textBaseline = 'alphabetic';
        ctx.font = '50px "Press Start 2P"'; ctx.fillText("è…¦åŠ›å¤§äº‚é¬¥", GAME_WIDTH/2, 180);
        ctx.font = '24px Noto Sans TC'; ctx.fillText("æŒ‰ [ç©ºç™½éµ] é–‹å§‹éŠæˆ²", GAME_WIDTH/2, 280);
        
        ctx.textAlign = 'left';
        ctx.fillStyle = p1.color; ctx.fillText(`${p1.emoji} ç©å®¶ 1: WASD`, 180, 380);
        ctx.fillStyle = p2.color; ctx.fillText(`${p2.emoji} ç©å®¶ 2: æ–¹å‘éµ`, 480, 380);
        
        // æ’è¡Œæ¦œå·²å¾æ­¤è™•ç§»é™¤

    } else if (currentState === STATE.INSTRUCTION) {
        ctx.fillStyle = '#f1c40f'; ctx.font = 'bold 60px Noto Sans TC'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(roundInstruction, GAME_WIDTH/2, GAME_HEIGHT/2);
        
    } else if (currentState === STATE.PLAYING) {
        currentMode.draw();
        
        ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(0, 0, GAME_WIDTH, 40); 
        ctx.textAlign = 'center'; ctx.textBaseline = 'alphabetic'; ctx.fillStyle = totalTime < 10 ? '#e74c3c' : 'white';
        ctx.font = '20px "Press Start 2P"'; ctx.fillText(`TIME: ${totalTime}`, GAME_WIDTH/2, 28);

        ctx.textAlign = 'left'; ctx.fillStyle = p1.color; ctx.fillText(`${p1.emoji} ${p1.score}`, 20, 28);
        ctx.textAlign = 'right'; ctx.fillStyle = p2.color; ctx.fillText(`${p2.score} ${p2.emoji}`, GAME_WIDTH - 20, 28);

    } else if (currentState === STATE.ROUND_END) {
        currentMode.draw();
        ctx.fillStyle = 'rgba(0,0,0,0.7)'; ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
        ctx.fillStyle = 'white'; ctx.font = '60px Noto Sans TC'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        if (roundWinner) {
            ctx.fillText(`${roundWinner.emoji} ç²å‹!`, GAME_WIDTH/2, GAME_HEIGHT/2);
            ctx.font = '30px Arial'; ctx.fillStyle = '#f1c40f'; ctx.fillText("+100 åˆ†", GAME_WIDTH/2, GAME_HEIGHT/2 + 50);
        } else ctx.fillText("æ™‚é–“åˆ°!", GAME_WIDTH/2, GAME_HEIGHT/2);

    } else if (currentState === STATE.GAME_OVER) {
        ctx.fillStyle = 'white'; ctx.font = '50px "Press Start 2P"'; ctx.textAlign = 'center'; ctx.textBaseline = 'alphabetic';
        ctx.fillText("GAME OVER", GAME_WIDTH/2, 120);
        
        ctx.font = '40px Noto Sans TC';
        ctx.fillStyle = p1.color; ctx.fillText(`P1: ${p1.score}`, GAME_WIDTH/2, 220);
        ctx.fillStyle = p2.color; ctx.fillText(`P2: ${p2.score}`, GAME_WIDTH/2, 280);

        let wText = p1.score > p2.score ? "Player 1 å‹åˆ©!" : (p2.score > p1.score ? "Player 2 å‹åˆ©!" : "å¹³æ‰‹!");
        ctx.fillStyle = '#f1c40f'; ctx.font = 'bold 50px Noto Sans TC'; ctx.fillText(wText, GAME_WIDTH/2, 380);
        ctx.fillStyle = 'white'; ctx.font = '20px Noto Sans TC'; ctx.fillText("æŒ‰ [ç©ºç™½éµ] é‡æ–°é–‹å§‹", GAME_WIDTH/2, 500);

        // æ’è¡Œæ¦œç§»è‡³æ­¤è™•
        drawLeaderboard();
    }
}

function saveScore() {
    let scores = JSON.parse(localStorage.getItem(LEADERBOARD_KEY) || "[]");
    if(p1.score > 0) scores.push({name: "P1", score: p1.score});
    if(p2.score > 0) scores.push({name: "P2", score: p2.score});
    scores.sort((a, b) => b.score - a.score);
    if(scores.length > 5) scores = scores.slice(0, 5);
    localStorage.setItem(LEADERBOARD_KEY, JSON.stringify(scores));
}

function drawLeaderboard() {
    let scores = JSON.parse(localStorage.getItem(LEADERBOARD_KEY) || "[]");
    ctx.fillStyle = 'white'; ctx.textAlign = 'center'; ctx.font = '16px Noto Sans TC'; ctx.textBaseline = 'alphabetic';
    ctx.fillText("--- æ­·å²æœ€é«˜åˆ† ---", GAME_WIDTH/2, 550);
    scores.forEach((s, i) => {
        ctx.fillStyle = '#bdc3c7'; ctx.fillText(`${i+1}. ${s.name} : ${s.score}`, GAME_WIDTH/2, 575 + i*20);
    });
}

function loop() {
    update(); draw(); requestAnimationFrame(loop);
}

function resize() {
    let scale = Math.min(window.innerWidth / GAME_WIDTH, window.innerHeight / GAME_HEIGHT);
    canvas.style.width = (GAME_WIDTH * scale) + 'px';
    canvas.style.height = (GAME_HEIGHT * scale) + 'px';
}
window.addEventListener('resize', resize);
resize();
loop();
</script>
</body>
</html>
