<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ÈÉ≠‰∏≠Êï∏È¨•Â§ßÊúÉ</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Noto+Sans+TC:wght@700&display=swap');

        body {
            margin: 0;
            padding: 0;
            background-color: #2c3e50;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            font-family: 'Noto Sans TC', sans-serif;
            color: white;
            user-select: none;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 30px rgba(0,0,0,0.6);
            border: 4px solid #f1c40f;
            border-radius: 8px;
            background-color: #34495e;
        }

        canvas {
            display: block;
        }

        .mobile-warning {
            display: none;
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            color: white;
            z-index: 999;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 20px;
            font-size: 1.2rem;
        }

        @media (hover: none) and (pointer: coarse) {
            .mobile-warning { display: flex; }
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div class="mobile-warning">Ë´ã‰ΩøÁî®ÈõªËÖ¶ÈçµÁõ§ÈÄ≤Ë°åÈõô‰∫∫Â∞çÊà∞‰ª•Áç≤ÂæóÊúÄ‰Ω≥È´îÈ©ó„ÄÇ</div>
</div>

<script>
/**
 * ÈÉ≠‰∏≠Êï∏È¨•Â§ßÊúÉ v8.0
 * Êõ¥Êñ∞ÔºöÂ•™ÂØ∂ÈÄ≤Â∫¶Ê≠∏Èõ∂„ÄÅÊï∏Á©çÊú®ÊåáÂÆö9È°åÂ∫´
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// --- Logo Ë®≠ÂÆö ---
const logoImage = new Image();
logoImage.src = 'WhatsApp Image 2025-12-29 at 5.18.31 PM.png'; // Ë´ãÂú®Ê≠§Â°´ÂÖ•ÊÇ®ÁöÑ Logo ÂúñÁâáË∑ØÂæëÊàñ Base64

// --- ÂÖ®Â±ÄËÆäÊï∏ ---
const GAME_WIDTH = 800;
const GAME_HEIGHT = 600;
const TEXT_Y_POS = 130;

const STATE = {
    MENU: 0,
    INSTRUCTION: 1,
    PLAYING: 2,
    ROUND_END: 3,
    GAME_OVER_INPUT: 4,
    GAME_OVER_SHOW: 5
};

let currentState = STATE.MENU;
let frameCount = 0;
let totalTime = 60;
let timeRemaining = 0;
let inputCooldown = 0; 

// Áé©ÂÆ∂ÈÖçÁΩÆ
const p1 = { score: 0, color: '#3498db', name: 'Player 1', emoji: 'ü§ñ', lastKey: null, lastKeyTime: 0, dash: false, stun: 0 };
const p2 = { score: 0, color: '#e74c3c', name: 'Player 2', emoji: 'ü¶ñ', lastKey: null, lastKeyTime: 0, dash: false, stun: 0 };

const keys = {};
let currentMode = null;
let roundWinner = null;
let roundInstruction = "";
let effects = []; 
let modeDeck = []; 

const LEADERBOARD_KEY = 'kywc_math_battle_ranking';
let winnerName = "";
let inputActive = false;
let gameWinner = null;

// --- Â∑•ÂÖ∑ÂáΩÊï∏ ---

function randomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

function rectIntersect(x1, y1, w1, h1, x2, y2, w2, h2) {
    return x2 < x1 + w1 && x2 + w2 > x1 && y2 < y1 + h1 && y2 + h2 > y1;
}

function circleIntersect(x1, y1, r1, x2, y2, r2) {
    let dist = Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2);
    return dist < r1 + r2;
}

function drawEmoji(emoji, x, y, size) {
    ctx.font = `${size}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(emoji, x, y);
}

const exitBtn = { x: 280, y: 10, w: 80, h: 30 };

// --- Ëº∏ÂÖ•ËôïÁêÜ ---
window.addEventListener('keydown', (e) => {
    if (currentState === STATE.GAME_OVER_INPUT && inputActive) {
        if (e.key.length === 1 && /[a-zA-Z]/.test(e.key)) {
            if (winnerName.length < 5) winnerName += e.key.toUpperCase();
        } else if (e.key === 'Backspace') {
            winnerName = winnerName.slice(0, -1);
        } else if (e.key === 'Enter') {
            if (winnerName.length >= 3) saveScoreAndProceed();
        }
        return;
    }

    if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight", "Space"].indexOf(e.code) > -1) {
        e.preventDefault();
    }
    const key = e.key.toLowerCase();
    const now = Date.now();
    let player = null;

    if (['w','a','s','d'].includes(key)) player = p1;
    if (['arrowup','arrowdown','arrowleft','arrowright'].includes(key)) player = p2;

    if (player && player.stun <= 0) {
        if (player.lastKey === key && now - player.lastKeyTime < 300) {
            player.dash = true; 
            setTimeout(() => player.dash = false, 500); 
        }
        player.lastKey = key;
        player.lastKeyTime = now;
    }

    keys[key] = true;
});

window.addEventListener('keyup', (e) => {
    const key = e.key.toLowerCase();
    keys[key] = false;
});

canvas.addEventListener('mousedown', (e) => {
    if (currentState === STATE.PLAYING) {
        const rect = canvas.getBoundingClientRect();
        const mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
        const mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);
        if (mouseX >= exitBtn.x && mouseX <= exitBtn.x + exitBtn.w &&
            mouseY >= exitBtn.y && mouseY <= exitBtn.y + exitBtn.h) {
            goToMenu();
        }
    }
});

// --- ÊµÅÁ®ãÊéßÂà∂ ---

function goToMenu() {
    currentState = STATE.MENU;
    inputCooldown = 30; 
    for (let k in keys) keys[k] = false;
}

function startNewGame() {
    p1.score = 0; p2.score = 0;
    p1.stun = 0; p2.stun = 0;
    totalTime = 60;
    modeDeck = []; 
    selectNextMode();
}

function selectNextMode() {
    if (modeDeck.length === 0) {
        modeDeck = [0, 1, 2, 3, 4];
        for (let i = modeDeck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [modeDeck[i], modeDeck[j]] = [modeDeck[j], modeDeck[i]];
        }
    }
    
    const nextIndex = modeDeck.pop();
    const modes = [ShooterMode, GeometryMode, CubeMode, ChaseMode, RainMode];
    
    currentMode = new modes[nextIndex]();
    currentMode.init();
    
    const instructions = ["Â∞ÑÊìäÊ≠£Á¢∫Á≠îÊ°àÔºÅ", "Êï∏Êï∏‰∏âËßíÂΩ¢ÔºÅ", "Êï∏Êï∏Á©çÊú®ÔºÅ", "ÁÆóÂá∫Á≠îÊ°à‰∏¶Êê∂Â•™ÔºÅ", "Êé•‰ΩèÊ≠£Á¢∫Á≠îÊ°àÔºÅ"];
    roundInstruction = instructions[nextIndex];
    
    currentState = STATE.INSTRUCTION;
    timeRemaining = 120; 
}

function endGameRound(winner) {
    roundWinner = winner;
    currentState = STATE.ROUND_END;
    timeRemaining = 60; 
    effects = [];
}

function initGameOver() {
    winnerName = "";
    inputActive = false;
    inputCooldown = 30; 
    
    if (p1.score > p2.score) gameWinner = 'p1';
    else if (p2.score > p1.score) gameWinner = 'p2';
    else gameWinner = 'draw';

    if (gameWinner !== 'draw') {
        currentState = STATE.GAME_OVER_INPUT;
        inputActive = true;
    } else {
        currentState = STATE.GAME_OVER_SHOW;
    }
}

function saveScoreAndProceed() {
    if (gameWinner !== 'draw' && winnerName.length >= 3) {
        let scores = JSON.parse(localStorage.getItem(LEADERBOARD_KEY) || "[]");
        let score = (gameWinner === 'p1') ? p1.score : p2.score;
        scores.push({name: winnerName, score: score});
        scores.sort((a, b) => b.score - a.score);
        if(scores.length > 10) scores = scores.slice(0, 10);
        localStorage.setItem(LEADERBOARD_KEY, JSON.stringify(scores));
    }
    currentState = STATE.GAME_OVER_SHOW;
    inputActive = false;
    inputCooldown = 30; 
}

// --- È°åÁõÆÁîüÊàêÂô® ---
function generateProblem(forceType = -1) {
    const difficulty = Math.min(1, (60 - totalTime) / 50); 
    
    let type;
    if (forceType !== -1) {
        type = forceType;
    } else {
        let r = Math.random();
        if (difficulty < 0.3) type = (r > 0.6) ? 1 : 0; 
        else if (difficulty < 0.6) type = (r > 0.4) ? 1 : (r > 0.8 ? 2 : 0);
        else type = (r > 0.5) ? 2 : 1;
    }

    let q = "", a = 0, options = [];

    if (type === 0) { // Âä†Ê∏õ
        let max = 10 + Math.floor(difficulty * 40);
        let n1 = randomInt(1, max);
        let n2 = randomInt(1, max);
        if (Math.random() > 0.5) {
            q = `${n1} + ${n2} = ?`;
            a = n1 + n2;
        } else {
            let big = Math.max(n1, n2);
            let small = Math.min(n1, n2);
            q = `${big} - ${small} = ?`;
            a = big - small;
        }
    } else if (type === 1) { // ‰πòÊ≥ï
        let maxMulti = 3 + Math.floor(difficulty * 8); 
        let n1 = randomInt(2, maxMulti);
        let n2 = randomInt(2, maxMulti);
        q = `${n1} √ó ${n2} = ?`;
        a = n1 * n2;
    } else { // Êï∏Âàó
        let start = randomInt(1, 10);
        let step = randomInt(2, 5);
        let idx = randomInt(2, 4); 
        let seq = [];
        for(let i=0; i<5; i++) seq.push(start + i*step);
        a = seq[idx];
        seq[idx] = '?';
        q = seq.join(', ');
    }

    while(options.length < 3) {
        let offset = randomInt(-5, 5);
        if (offset === 0) continue;
        let wrong = a + offset;
        if (wrong < 0) wrong = Math.abs(wrong);
        if (wrong !== a && !options.includes(wrong)) options.push(wrong);
    }
    options.push(a); 
    options.sort(() => Math.random() - 0.5);

    return { text: q, answer: a, options: options };
}

// --- ÈÅäÊà≤Ê®°ÂºèÂü∫È°û ---
class GameMode {
    constructor() {
        this.winner = null;
        this.problem = generateProblem();
    }
    init() {}
    update() {}
    draw() {}
    checkWin(player) {
        if (!this.winner) {
            this.winner = player;
            player.score += 100;
            setTimeout(() => { if (currentState === STATE.PLAYING) endGameRound(player); }, 500); 
        } else if (this.winner !== player) {
             player.score += 50;
        }
    }
    drawOptionText(val, x, y, keyHint) {
        ctx.beginPath();
        ctx.arc(x, y, 35, 0, Math.PI*2);
        ctx.fillStyle = 'rgba(0,0,0,0.8)';
        ctx.fill();
        ctx.lineWidth = 4;
        ctx.strokeStyle = '#f1c40f'; 
        ctx.stroke();

        ctx.fillStyle = 'white'; 
        ctx.font = 'bold 30px Arial'; 
        ctx.textAlign = 'center'; 
        ctx.textBaseline = 'middle';
        ctx.fillText(val, x, y + 2); 

        ctx.fillStyle = '#f1c40f'; 
        ctx.font = 'bold 20px Arial'; 
        ctx.fillText(keyHint, x, y + 60);
    }
}

// Mode 1: ÂºìÁÆ≠Â∞ÑÊìä
class ShooterMode extends GameMode {
    constructor() { super(); this.bullets = []; this.targets = []; this.p1Angle = 0; this.p2Angle = 0; this.p1Cooldown = 0; this.p2Cooldown = 0; }
    init() {
        let pool = this.problem.options.slice(0, 4);
        pool.forEach(opt => {
            this.targets.push({
                x: randomInt(100, 700), y: randomInt(180, 300),
                vx: (Math.random() - 0.5) * 4, vy: (Math.random() - 0.5) * 4,
                val: opt, r: 25, type: opt === this.problem.answer ? 'correct' : 'wrong'
            });
        });
        this.walls = [{x: 350, y: 300, w: 100, h: 20}, {x: 100, y: 150, w: 20, h: 100}, {x: 680, y: 150, w: 20, h: 100}];
    }
    update() {
        if (keys['a']) this.p1Angle -= 0.05; if (keys['d']) this.p1Angle += 0.05;
        this.p1Angle = Math.max(-1.2, Math.min(1.2, this.p1Angle));
        if (keys['w'] && this.p1Cooldown <= 0) {
            this.bullets.push({x: 100 + Math.sin(this.p1Angle)*20, y: 550 - Math.cos(this.p1Angle)*20, vx: Math.sin(this.p1Angle)*15, vy: -Math.cos(this.p1Angle)*15, angle: this.p1Angle, owner: p1, life: 100});
            this.p1Cooldown = 30; 
        }
        if (keys['arrowleft']) this.p2Angle -= 0.05; if (keys['arrowright']) this.p2Angle += 0.05;
        this.p2Angle = Math.max(-1.2, Math.min(1.2, this.p2Angle));
        if (keys['arrowup'] && this.p2Cooldown <= 0) {
            this.bullets.push({x: 700 + Math.sin(this.p2Angle)*20, y: 550 - Math.cos(this.p2Angle)*20, vx: Math.sin(this.p2Angle)*15, vy: -Math.cos(this.p2Angle)*15, angle: this.p2Angle, owner: p2, life: 100});
            this.p2Cooldown = 30;
        }
        if (this.p1Cooldown > 0) this.p1Cooldown--; if (this.p2Cooldown > 0) this.p2Cooldown--;
        this.targets.forEach(t => {
            t.x += t.vx; t.y += t.vy;
            if (t.x < t.r || t.x > GAME_WIDTH - t.r) t.vx *= -1; if (t.y < t.r || t.y > 400) t.vy *= -1;
        });
        for (let i = this.bullets.length - 1; i >= 0; i--) {
            let b = this.bullets[i]; b.x += b.vx; b.y += b.vy; b.life--;
            if (b.x < 0 || b.x > GAME_WIDTH) b.vx *= -1; if (b.y < 0) b.vy *= -1; 
            this.walls.forEach(w => { if (rectIntersect(b.x, b.y, 5, 5, w.x, w.y, w.w, w.h)) b.vy *= -1; });
            for (let t of this.targets) {
                if (circleIntersect(b.x, b.y, 5, t.x, t.y, t.r)) {
                    if (t.type === 'correct') this.checkWin(b.owner); else b.life = 0; 
                    this.bullets.splice(i, 1); break;
                }
            }
            if (b.life <= 0 || b.y > 600) this.bullets.splice(i, 1);
        }
    }
    draw() {
        ctx.fillStyle = 'white'; ctx.font = '30px Noto Sans TC'; ctx.textAlign = 'center'; ctx.textBaseline = 'alphabetic';
        ctx.fillText(`Â∞ÑÊìäÊ≠£Á¢∫Á≠îÊ°à: ${this.problem.text}`, GAME_WIDTH/2, TEXT_Y_POS);
        this.targets.forEach(t => {
            ctx.fillStyle = '#ecf0f1'; ctx.beginPath(); ctx.arc(t.x, t.y, t.r, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#2c3e50'; ctx.font = 'bold 20px Arial'; ctx.textBaseline = 'middle'; ctx.fillText(t.val, t.x, t.y);
        });
        ctx.fillStyle = '#7f8c8d';
        this.walls.forEach(w => { ctx.fillRect(w.x, w.y, w.w, w.h); drawEmoji('üß±', w.x + w.w/2, w.y + w.h/2, 20); });
        const drawBow = (x, angle, emoji) => {
            ctx.save(); ctx.translate(x, 550); ctx.rotate(angle);
            ctx.beginPath(); ctx.arc(0, 10, 40, Math.PI, 0); ctx.lineWidth = 5; ctx.strokeStyle = '#d35400'; ctx.stroke();
            ctx.beginPath(); ctx.moveTo(-40, 10); ctx.lineTo(40, 10); ctx.lineWidth = 1; ctx.strokeStyle = '#ecf0f1'; ctx.stroke();
            ctx.restore(); drawEmoji(emoji, x, 580, 25);
        };
        drawBow(100, this.p1Angle, p1.emoji); drawBow(700, this.p2Angle, p2.emoji);
        this.bullets.forEach(b => {
            ctx.save(); ctx.translate(b.x, b.y); ctx.rotate(b.angle);
            ctx.beginPath(); ctx.moveTo(0, 10); ctx.lineTo(0, -10); ctx.lineWidth = 2; ctx.strokeStyle = '#f1c40f'; ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0, -15); ctx.lineTo(-5, -5); ctx.lineTo(5, -5); ctx.closePath(); ctx.fillStyle = '#e74c3c'; ctx.fill();
            ctx.beginPath(); ctx.moveTo(0, 10); ctx.lineTo(-4, 15); ctx.moveTo(0, 10); ctx.lineTo(4, 15); ctx.stroke();
            ctx.restore();
        });
    }
}

// Mode 2: Êï∏Âπæ‰ΩïÂúñÂΩ¢
class GeometryMode extends GameMode {
    constructor() {
        super();
        this.problem.text = "Âúñ‰∏≠ÂÖ±ÊúâÂ§öÂ∞ëÂÄã‰∏âËßíÂΩ¢Ôºü";
        
        let seed = Math.random();
        if (seed < 0.25) {
            this.preset = 0;
            let segments, layers, count;
            do {
                segments = randomInt(2, 3); layers = randomInt(1, 2);   
                count = (segments * (segments + 1) / 2) * layers;
            } while (count > 9);
            this.problem.answer = count;
            this.structure = { segments: segments, layers: layers };
        } else if (seed < 0.5) {
            this.preset = 1; this.problem.answer = 12;
        } else if (seed < 0.75) {
            this.preset = 2; this.problem.answer = 5;
        } else {
            this.preset = 3; this.problem.answer = 5;
        }

        this.options = { 'Up': 0, 'Down': 0, 'Left': 0, 'Right': 0 };
        let keys = Object.keys(this.options);
        let correctKey = keys[randomInt(0, 3)];
        let count = this.problem.answer;
        
        keys.forEach(k => {
            if (k === correctKey) this.options[k] = count;
            else {
                let n = count + randomInt(-2, 2);
                while (n === count || n <= 0) n = count + randomInt(-3, 3);
                this.options[k] = n;
            }
        });
    }

    update() {
        if (keys['w']) this.checkAnswer(p1, 'Up'); else if (keys['s']) this.checkAnswer(p1, 'Down');
        else if (keys['a']) this.checkAnswer(p1, 'Left'); else if (keys['d']) this.checkAnswer(p1, 'Right');
        if (keys['arrowup']) this.checkAnswer(p2, 'Up'); else if (keys['arrowdown']) this.checkAnswer(p2, 'Down');
        else if (keys['arrowleft']) this.checkAnswer(p2, 'Left'); else if (keys['arrowright']) this.checkAnswer(p2, 'Right');
    }

    checkAnswer(player, dir) {
        if (this.winner === player) return;
        if (player.lock) return;
        if (this.options[dir] === this.problem.answer) this.checkWin(player);
        else { player.score = Math.max(0, player.score - 10); player.lock = true; setTimeout(() => player.lock = false, 500); }
    }

    draw() {
        ctx.fillStyle = 'white'; ctx.font = '30px Noto Sans TC'; ctx.textAlign = 'center'; ctx.textBaseline = 'alphabetic';
        ctx.fillText(this.problem.text, GAME_WIDTH/2, TEXT_Y_POS);

        const topX = GAME_WIDTH / 2;
        const topY = 200; 
        const baseY = 460;
        const baseWidth = 300;
        const leftX = topX - baseWidth / 2;
        const rightX = topX + baseWidth / 2;

        ctx.strokeStyle = '#f1c40f'; ctx.lineWidth = 5; ctx.lineJoin = 'round'; ctx.lineCap = 'round';
        
        if (this.preset === 0) { 
            ctx.beginPath(); ctx.moveTo(topX, topY); ctx.lineTo(leftX, baseY); ctx.lineTo(rightX, baseY); ctx.closePath(); ctx.stroke();
            let segs = this.structure.segments;
            for (let i = 1; i < segs; i++) {
                let r = i / segs;
                ctx.beginPath(); ctx.moveTo(topX, topY); ctx.lineTo(leftX + baseWidth * r, baseY); ctx.stroke();
            }
            let lays = this.structure.layers;
            for (let i = 1; i < lays; i++) {
                let r = i / lays;
                ctx.beginPath(); 
                ctx.moveTo(topX - (baseWidth/2)*r, topY + (baseY-topY)*r); 
                ctx.lineTo(topX + (baseWidth/2)*r, topY + (baseY-topY)*r); 
                ctx.stroke();
            }
        } else if (this.preset === 1) { 
            ctx.beginPath(); ctx.moveTo(topX, topY); ctx.lineTo(leftX, baseY); ctx.lineTo(rightX, baseY); ctx.closePath(); ctx.stroke();
            for(let i=1; i<=2; i++){
                let r = i/3;
                ctx.beginPath(); ctx.moveTo(topX, topY); ctx.lineTo(leftX + baseWidth*r, baseY); ctx.stroke();
            }
            let midY = (topY + baseY) / 2;
            let midLx = (topX + leftX) / 2;
            let midRx = (topX + rightX) / 2;
            ctx.beginPath(); ctx.moveTo(midLx, midY); ctx.lineTo(midRx, midY); ctx.stroke();

        } else if (this.preset === 2) { 
            ctx.beginPath(); ctx.moveTo(topX, topY); ctx.lineTo(leftX, baseY); ctx.lineTo(rightX, baseY); ctx.closePath(); ctx.stroke();
            let mLeftX = (topX + leftX)/2, mLeftY = (topY + baseY)/2;
            let mRightX = (topX + rightX)/2, mRightY = (topY + baseY)/2;
            let mBaseX = topX, mBaseY = baseY;
            ctx.beginPath();
            ctx.moveTo(mLeftX, mLeftY); ctx.lineTo(mRightX, mRightY);
            ctx.lineTo(mBaseX, mBaseY); ctx.closePath();
            ctx.stroke();

        } else if (this.preset === 3) { 
            ctx.beginPath(); ctx.moveTo(topX, topY); ctx.lineTo(leftX, baseY); ctx.lineTo(rightX, baseY); ctx.closePath(); ctx.stroke();
            let dX = topX + (rightX - topX) * 0.6; 
            let dY = topY + (baseY - topY) * 0.6;
            ctx.beginPath(); ctx.moveTo(leftX, baseY); ctx.lineTo(dX, dY); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(dX, dY); ctx.lineTo(dX, baseY); ctx.stroke();
        }

        this.drawOptionText(this.options.Up, GAME_WIDTH/2, 120, '‚Üë W');
        this.drawOptionText(this.options.Down, GAME_WIDTH/2, 550, '‚Üì S');
        this.drawOptionText(this.options.Left, 100, 300, '‚Üê A');
        this.drawOptionText(this.options.Right, 700, 300, '‚Üí D');
    }
}

// Mode 3: Êï∏Á©çÊú® (ÊåáÂÆö9È°å)
class CubeMode extends GeometryMode {
    constructor() {
        super();
        this.preset = -1; 
        this.problem.text = "Êï∏Êï∏ÊúâÂ§öÂ∞ëÂÄãÁ©çÊú®Ôºü";
        
        // ÂÆöÁæ©9ÂÄãÁâπÂÆöÂΩ¢ÁãÄ (x, yÊòØÁ∂≤Ê†ºÂùêÊ®ô, hÊòØÈ´òÂ∫¶)
        // ÈÄô‰∫õÁµêÊßãÂ∞çÊáâÊÇ®ÂúñÁâá‰∏≠ÁöÑ9Á®ÆÁ©çÊú®ÁµÑÂêà
        const cubePresets = [
            [{x:0, y:1, h:2}, {x:1, y:1, h:1}, {x:2, y:1, h:1}, {x:1, y:0, h:1}], // TÂûãËÆäÈ´î (5)
            [{x:1, y:1, h:2}, {x:0, y:1, h:1}, {x:2, y:1, h:1}, {x:1, y:0, h:1}, {x:1, y:2, h:1}], // ÂçÅÂ≠óÈ´òÂ°î (6)
            [{x:1, y:1, h:2}, {x:0, y:1, h:1}, {x:2, y:1, h:1}, {x:1, y:0, h:1}, {x:1, y:2, h:1}], // ÂçÅÂ≠óÈ´òÂ°îËÆäËâ≤ (6)
            [{x:1, y:1, h:2}, {x:0, y:1, h:1}, {x:2, y:1, h:1}, {x:1, y:0, h:1}], // TÂûã (5)
            [{x:0, y:1, h:2}, {x:1, y:1, h:2}, {x:2, y:1, h:1}, {x:0, y:0, h:1}, {x:1, y:0, h:1}], // ÈöéÊ¢ØÂûã (7)
            [{x:0, y:1, h:2}, {x:1, y:1, h:2}, {x:0, y:0, h:1}, {x:1, y:0, h:2}], // 2x2Áº∫Ëßí (7)
            [{x:0, y:1, h:2}, {x:1, y:1, h:1}, {x:2, y:1, h:1}, {x:0, y:0, h:1}], // ËßíËêΩÂûã (5)
            [{x:0, y:1, h:2}, {x:1, y:1, h:2}, {x:0, y:0, h:1}, {x:1, y:0, h:1}], // È†íÁçéÂè∞ (6)
            [{x:0, y:1, h:2}, {x:1, y:1, h:2}, {x:0, y:0, h:2}, {x:1, y:0, h:1}]  // 2x2Áº∫È†Ç (7)
        ];

        // Èö®Ê©üÈÅ∏‰∏ÄÈ°å
        let choice = cubePresets[randomInt(0, cubePresets.length - 1)];
        this.cubes = [];
        let totalCubes = 0;

        // Âª∫ÊßãÁ©çÊú®‰∏¶Ë®àÁÆóÁ∏ΩÊï∏
        choice.forEach(block => {
            for(let z=0; z<block.h; z++) {
                this.cubes.push({gx: block.x, gy: block.y, gz: z});
            }
            totalCubes += block.h;
        });

        this.problem.answer = totalCubes;
        this.options = { 'Up': 0, 'Down': 0, 'Left': 0, 'Right': 0 };
        let keys = Object.keys(this.options); let correctKey = keys[randomInt(0, 3)];
        
        keys.forEach(k => {
            if (k === correctKey) this.options[k] = totalCubes;
            else {
                let n = totalCubes + randomInt(-3, 3);
                while (n === totalCubes || n <= 0) n = totalCubes + randomInt(-4, 4);
                this.options[k] = n;
            }
        });
    }
    draw() {
        ctx.fillStyle = 'white'; ctx.font = '30px Noto Sans TC'; ctx.textAlign = 'center'; ctx.textBaseline = 'alphabetic';
        ctx.fillText(this.problem.text, GAME_WIDTH/2, TEXT_Y_POS);
        let originX = GAME_WIDTH / 2; let originY = 380; let size = 40;     
        // ÊéíÂ∫è‰ª•Á¢∫‰øùÊ≠£Á¢∫ÈÅÆÊìã
        this.cubes.sort((a, b) => {
            let depthA = a.gx + a.gy; let depthB = b.gx + b.gy;
            if (depthA !== depthB) return depthA - depthB; return a.gz - b.gz;
        });
        this.cubes.forEach(c => {
            let x = (c.gx - c.gy) * size + originX; let y = (c.gx + c.gy) * size * 0.5 - (c.gz * size) + originY;
            this.drawCube(x, y, size);
        });
        this.drawOptionText(this.options.Up, GAME_WIDTH/2, 120, '‚Üë W');
        this.drawOptionText(this.options.Down, GAME_WIDTH/2, 550, '‚Üì S');
        this.drawOptionText(this.options.Left, 100, 300, '‚Üê A');
        this.drawOptionText(this.options.Right, 700, 300, '‚Üí D');
    }
    drawCube(x, y, size) {
        ctx.lineWidth = 1; ctx.strokeStyle = '#2c3e50';
        ctx.fillStyle = '#e74c3c'; ctx.beginPath(); ctx.moveTo(x, y - size); ctx.lineTo(x + size, y - size * 1.5); ctx.lineTo(x, y - size * 2); ctx.lineTo(x - size, y - size * 1.5); ctx.fill(); ctx.stroke();
        ctx.fillStyle = '#c0392b'; ctx.beginPath(); ctx.moveTo(x, y - size); ctx.lineTo(x + size, y - size * 1.5); ctx.lineTo(x + size, y - size * 0.5); ctx.lineTo(x, y); ctx.fill(); ctx.stroke();
        ctx.fillStyle = '#e67e22'; ctx.beginPath(); ctx.moveTo(x, y - size); ctx.lineTo(x - size, y - size * 1.5); ctx.lineTo(x - size, y - size * 0.5); ctx.lineTo(x, y); ctx.fill(); ctx.stroke();
    }
}

// Mode 4: Â•™ÂØ∂ËøΩÈÄê
class ChaseMode extends GameMode {
    constructor() {
        super();
        this.problem = generateProblem(); this.problem.text = "ÁÆóÂá∫Á≠îÊ°à‰∏¶Êê∂Â•™ÔºÅ" + this.problem.text;
        this.holder = null; this.holdTime = 0; this.targetTime = 180; this.stealCooldown = 0; this.items = [];
        let correct = this.problem.answer; let others = this.problem.options.filter(o => o !== correct);
        while (others.length < 2) { let w = correct + randomInt(1, 5); if (!others.includes(w) && w !== correct) others.push(w); }
        let pool = [correct, others[0], others[1]]; pool.sort(() => Math.random() - 0.5);
        pool.forEach((val) => {
            this.items.push({ x: randomInt(100, 700), y: randomInt(180, 500), vx: (Math.random()-0.5)*2, vy: (Math.random()-0.5)*2, val: val, isCorrect: (val === correct) });
        });
        this.p1Pos = { x: 150, y: 300, cooldown: 0 }; this.p2Pos = { x: 650, y: 300, cooldown: 0 };
    }
    update() {
        this.movePlayer(this.p1Pos, 'w', 's', 'a', 'd', p1); this.movePlayer(this.p2Pos, 'arrowup', 'arrowdown', 'arrowleft', 'arrowright', p2);
        this.items.forEach(item => {
            if (this.holder && item.isCorrect) { let pos = this.holder === p1 ? this.p1Pos : this.p2Pos; item.x = pos.x; item.y = pos.y - 45; }
            else { item.x += item.vx; item.y += item.vy; if(item.x < 30 || item.x > GAME_WIDTH-30) item.vx *= -1; if(item.y < 30 || item.y > GAME_HEIGHT-30) item.vy *= -1; }
        });
        if (!this.holder) { this.checkPickUp(p1, this.p1Pos); this.checkPickUp(p2, this.p2Pos); }
        else { this.holdTime++; if (this.holdTime >= this.targetTime) this.checkWin(this.holder); }
        this.checkSteal();
        if(p1.stun > 0) p1.stun--; if(p2.stun > 0) p2.stun--; if(this.stealCooldown > 0) this.stealCooldown--;
    }
    checkPickUp(player, pos) {
        if (player.stun > 0) return;
        for (let item of this.items) {
            if (circleIntersect(pos.x, pos.y, 30, item.x, item.y, 30)) {
                if (item.isCorrect) { this.holder = player; this.stealCooldown = 30; } else { player.stun = 60; pos.x -= item.vx * 10; }
            }
        }
    }
    movePlayer(pos, u, d, l, r, playerRef) {
        if (playerRef.stun > 0) return; 
        let speed = 5; if (this.holder === playerRef) speed = 4; if (playerRef.dash) speed = 10; 
        if (keys[u]) pos.y -= speed; if (keys[d]) pos.y += speed; if (keys[l]) pos.x -= speed; if (keys[r]) pos.x += speed;
        pos.x = Math.max(30, Math.min(GAME_WIDTH - 30, pos.x)); pos.y = Math.max(30, Math.min(GAME_HEIGHT - 30, pos.y));
    }
    checkSteal() {
        if (!this.holder || this.stealCooldown > 0) return;
        let dist = Math.sqrt((this.p1Pos.x - this.p2Pos.x)**2 + (this.p1Pos.y - this.p2Pos.y)**2);
        if (dist < 80) {
            if (p1.dash && this.holder === p2) this.performSteal(p1, p2, this.p2Pos);
            else if (p2.dash && this.holder === p1) this.performSteal(p2, p1, this.p1Pos);
        }
    }
    performSteal(stealer, victim, victimPos) {
        this.holder = stealer; 
        this.holdTime = 0; // ÈáçÁΩÆÈÄ≤Â∫¶ÔºÅ
        this.stealCooldown = 60; 
        victimPos.x += (stealer === p1 ? 60 : -60); effects.push({text: "STEAL!", x: victimPos.x, y: victimPos.y, life: 30});
    }
    draw() {
        ctx.fillStyle = 'white'; ctx.font = '30px Noto Sans TC'; ctx.textAlign = 'center'; ctx.textBaseline = 'alphabetic';
        let probPart = this.problem.text.split("ÔºÅ")[1] || this.problem.text; ctx.fillText(`ÁÆóÂá∫ ${probPart} ‰∏¶Êê∂Â•™ÔºÅ`, GAME_WIDTH/2, TEXT_Y_POS);
        const drawPlayer = (p, pos) => {
            drawEmoji(p.emoji, pos.x, pos.y, 50);
            if (p.stun > 0) drawEmoji('üí´', pos.x, pos.y - 30, 30); if (p.dash) drawEmoji('üí®', pos.x - 20, pos.y, 30);
            if (this.holder === p) { ctx.beginPath(); ctx.arc(pos.x, pos.y, 35, 0, Math.PI*2); ctx.strokeStyle = '#f1c40f'; ctx.lineWidth = 3; ctx.stroke(); }
        };
        drawPlayer(p1, this.p1Pos); drawPlayer(p2, this.p2Pos);
        this.items.forEach(item => {
            ctx.beginPath(); ctx.arc(item.x, item.y, 30, 0, Math.PI*2);
            ctx.fillStyle = '#f39c12'; ctx.fill(); ctx.strokeStyle = '#ecf0f1'; ctx.lineWidth = 3; ctx.stroke();
            ctx.fillStyle = 'white'; ctx.font = 'bold 24px Arial'; ctx.textBaseline = 'middle'; ctx.fillText(item.val, item.x, item.y);
        });
        if (this.holder) {
            ctx.fillStyle = this.holder.color; let w = (this.holdTime / this.targetTime) * 300;
            ctx.fillRect(GAME_WIDTH/2 - 150, 80, w, 20); ctx.strokeStyle = 'white'; ctx.lineWidth = 2; ctx.strokeRect(GAME_WIDTH/2 - 150, 80, 300, 20);
        }
    }
}

// Mode 5: Êï∏Â≠óÈõ®
class RainMode extends GameMode {
    constructor() {
        super(); this.items = []; this.spawnTimer = 0; this.p1X = 200; this.p2X = 600;
        if(this.problem.text.includes(',')) this.problem = generateProblem(0); 
    }
    update() {
        if (keys['a']) this.p1X -= 8; if (keys['d']) this.p1X += 8;
        if (keys['arrowleft']) this.p2X -= 8; if (keys['arrowright']) this.p2X += 8;
        this.p1X = Math.max(30, Math.min(GAME_WIDTH - 30, this.p1X)); this.p2X = Math.max(30, Math.min(GAME_WIDTH - 30, this.p2X));
        this.spawnTimer++;
        if (this.spawnTimer > 40) {
            this.spawnTimer = 0; let r = Math.random(); let type = 'wrong'; let val = 0;
            if (r > 0.7) { type = 'correct'; val = this.problem.answer; } else if (r < 0.2) { type = 'bomb'; val = ''; }
            else { val = this.problem.answer + randomInt(1, 10) * (Math.random()>0.5?1:-1); }
            this.items.push({ x: randomInt(30, GAME_WIDTH - 30), y: -30, type: type, val: val, speed: 3 + Math.random() * 3 });
        }
        for (let i = this.items.length - 1; i >= 0; i--) {
            let item = this.items[i]; item.y += item.speed;
            if (Math.abs(item.x - this.p1X) < 40 && Math.abs(item.y - 550) < 40) { this.handleCatch(p1, item, i); continue; }
            if (Math.abs(item.x - this.p2X) < 40 && Math.abs(item.y - 550) < 40) { this.handleCatch(p2, item, i); continue; }
            if (item.y > GAME_HEIGHT) this.items.splice(i, 1);
        }
    }
    handleCatch(player, item, index) {
        this.items.splice(index, 1);
        if (item.type === 'correct') this.checkWin(player); else if (item.type === 'bomb') player.score = Math.max(0, player.score - 50); else player.score = Math.max(0, player.score - 10);
    }
    draw() {
        ctx.fillStyle = 'white'; ctx.font = '30px Noto Sans TC'; ctx.textAlign = 'center'; ctx.textBaseline = 'alphabetic';
        ctx.fillText(`Êé•‰ΩèÊ≠£Á¢∫Á≠îÊ°à: ${this.problem.text}`, GAME_WIDTH/2, TEXT_Y_POS);
        drawEmoji(p1.emoji, this.p1X, 550, 60); drawEmoji(p2.emoji, this.p2X, 550, 60);
        this.items.forEach(item => {
            if (item.type === 'bomb') drawEmoji('üí£', item.x, item.y, 40);
            else {
                ctx.fillStyle = '#ecf0f1'; ctx.beginPath(); ctx.arc(item.x, item.y, 25, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = 'black'; ctx.font = '20px Arial'; ctx.textBaseline = 'middle'; ctx.fillText(item.val, item.x, item.y);
            }
        });
    }
}

// Âæ™Áí∞Êõ¥Êñ∞
function update() {
    frameCount++;
    if (inputCooldown > 0) inputCooldown--;

    if (currentState === STATE.MENU) {
        if (keys[' '] && inputCooldown <= 0) { 
            startNewGame(); 
        }
    } else if (currentState === STATE.INSTRUCTION) {
        timeRemaining--;
        if (timeRemaining <= 0) currentState = STATE.PLAYING;
    } else if (currentState === STATE.PLAYING) {
        if (frameCount % 60 === 0) totalTime--;
        if (totalTime <= 0) { 
            initGameOver();
        } else {
            currentMode.update();
            for(let i=effects.length-1; i>=0; i--) {
                effects[i].y -= 1; effects[i].life--; if(effects[i].life <= 0) effects.splice(i, 1);
            }
        }
    } else if (currentState === STATE.ROUND_END) {
        timeRemaining--;
        if (timeRemaining <= 0) selectNextMode();
    } else if (currentState === STATE.GAME_OVER_INPUT || currentState === STATE.GAME_OVER_SHOW) {
        if (currentState === STATE.GAME_OVER_SHOW && keys[' '] && inputCooldown <= 0) {
            goToMenu(); 
        }
    }
}

function draw() {
    ctx.fillStyle = '#2c3e50';
    ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

    if (currentState === STATE.MENU) {
        if (logoImage.src) {
            try {
                let logoW = 100; let scale = logoW / logoImage.width; let logoH = logoImage.height * scale;
                ctx.drawImage(logoImage, GAME_WIDTH - logoW - 20, 20, logoW, logoH);
            } catch(e) {
                ctx.strokeStyle = 'white'; ctx.strokeRect(GAME_WIDTH - 120, 20, 100, 100);
            }
        } else {
            ctx.strokeStyle = '#95a5a6'; ctx.lineWidth = 2; ctx.strokeRect(GAME_WIDTH - 120, 20, 100, 100);
            ctx.fillStyle = '#95a5a6'; ctx.font = '12px Arial'; ctx.fillText("LOGO", GAME_WIDTH - 70, 70);
        }

        ctx.fillStyle = 'white'; ctx.textAlign = 'center'; ctx.textBaseline = 'alphabetic';
        ctx.font = '50px "Press Start 2P"'; ctx.fillText("ÈÉ≠‰∏≠Êï∏È¨•Â§ßÊúÉ", GAME_WIDTH/2, 250);
        ctx.font = '24px Noto Sans TC'; ctx.fillText("Êåâ [Á©∫ÁôΩÈçµ] ÈñãÂßãÈÅäÊà≤", GAME_WIDTH/2, 350);
        
        ctx.textAlign = 'left'; ctx.fillStyle = p1.color; ctx.fillText(`${p1.emoji} Áé©ÂÆ∂ 1: WASD (ÈõôÊìäË°ùÂà∫)`, 20, 500);
        ctx.textAlign = 'right'; ctx.fillStyle = p2.color; ctx.fillText(`Áé©ÂÆ∂ 2: ÊñπÂêëÈçµ (ÈõôÊìäË°ùÂà∫) ${p2.emoji}`, GAME_WIDTH - 20, 500);

    } else if (currentState === STATE.INSTRUCTION) {
        ctx.fillStyle = '#f1c40f'; ctx.font = 'bold 60px Noto Sans TC'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(roundInstruction, GAME_WIDTH/2, GAME_HEIGHT/2);
        
    } else if (currentState === STATE.PLAYING) {
        currentMode.draw();
        effects.forEach(e => { ctx.fillStyle = '#f1c40f'; ctx.font = 'bold 20px Arial'; ctx.fillText(e.text, e.x, e.y); });
        
        ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(0, 0, GAME_WIDTH, 40); 
        ctx.fillStyle = '#c0392b'; ctx.fillRect(exitBtn.x, exitBtn.y, exitBtn.w, exitBtn.h);
        ctx.fillStyle = 'white'; ctx.font = 'bold 16px Noto Sans TC'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText("ÈÄÄÂá∫", exitBtn.x + exitBtn.w/2, exitBtn.y + exitBtn.h/2);

        ctx.fillStyle = totalTime < 10 ? '#e74c3c' : 'white'; ctx.font = '20px "Press Start 2P"'; 
        ctx.fillText(`TIME: ${totalTime}`, GAME_WIDTH/2 + 50, 25); 

        ctx.textAlign = 'left'; ctx.fillStyle = p1.color; ctx.fillText(`${p1.emoji} ${p1.score}`, 20, 28);
        ctx.textAlign = 'right'; ctx.fillStyle = p2.color; ctx.fillText(`${p2.score} ${p2.emoji}`, GAME_WIDTH - 20, 28);

    } else if (currentState === STATE.ROUND_END) {
        currentMode.draw();
        ctx.fillStyle = 'rgba(0,0,0,0.7)'; ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
        ctx.fillStyle = 'white'; ctx.font = '60px Noto Sans TC'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        if (roundWinner) {
            ctx.fillText(`${roundWinner.emoji} Áç≤Âãù!`, GAME_WIDTH/2, GAME_HEIGHT/2);
            ctx.font = '30px Arial'; ctx.fillStyle = '#f1c40f'; ctx.fillText("+100 ÂàÜ", GAME_WIDTH/2, GAME_HEIGHT/2 + 50);
        } else ctx.fillText("ÊôÇÈñìÂà∞!", GAME_WIDTH/2, GAME_HEIGHT/2);

    } else if (currentState === STATE.GAME_OVER_INPUT || currentState === STATE.GAME_OVER_SHOW) {
        ctx.fillStyle = '#2c3e50'; ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
        ctx.strokeStyle = 'rgba(255,255,255,0.2)'; ctx.lineWidth = 2; ctx.beginPath();
        ctx.moveTo(GAME_WIDTH/3, 50); ctx.lineTo(GAME_WIDTH/3, GAME_HEIGHT-50);
        ctx.moveTo(GAME_WIDTH*2/3, 50); ctx.lineTo(GAME_WIDTH*2/3, GAME_HEIGHT-50); ctx.stroke();

        let col1Center = GAME_WIDTH/6;
        ctx.fillStyle = p1.color; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.font = '40px sans-serif'; ctx.fillText(p1.emoji, col1Center, 150);
        ctx.font = '30px Noto Sans TC'; ctx.fillText("Player 1", col1Center, 220);
        ctx.font = '50px "Press Start 2P"'; ctx.fillText(p1.score, col1Center, 300);
        let p1Status = (gameWinner === 'p1') ? "ÂãùÂà©!" : (gameWinner === 'draw' ? "Âπ≥Êâã" : "ËêΩÊïó‚Ä¶");
        ctx.fillStyle = (gameWinner === 'p1') ? '#f1c40f' : '#95a5a6'; ctx.font = '40px Noto Sans TC'; ctx.fillText(p1Status, col1Center, 400);

        let col3Center = GAME_WIDTH * 5/6;
        ctx.fillStyle = p2.color; ctx.font = '40px sans-serif'; ctx.fillText(p2.emoji, col3Center, 150);
        ctx.font = '30px Noto Sans TC'; ctx.fillText("Player 2", col3Center, 220);
        ctx.font = '50px "Press Start 2P"'; ctx.fillText(p2.score, col3Center, 300);
        let p2Status = (gameWinner === 'p2') ? "ÂãùÂà©!" : (gameWinner === 'draw' ? "Âπ≥Êâã" : "ËêΩÊïó‚Ä¶");
        ctx.fillStyle = (gameWinner === 'p2') ? '#f1c40f' : '#95a5a6'; ctx.font = '40px Noto Sans TC'; ctx.fillText(p2Status, col3Center, 400);

        let col2Center = GAME_WIDTH / 2;
        if (currentState === STATE.GAME_OVER_INPUT) {
            ctx.fillStyle = 'white'; ctx.font = '24px Noto Sans TC'; 
            ctx.fillText("ÊÅ≠ÂñúÂãùÂà©!", col2Center, 150); ctx.fillText("Ë´ãËº∏ÂÖ•ÂêçÂ≠ó (3-5Â≠ó):", col2Center, 200);
            ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(col2Center - 100, 250, 200, 50);
            ctx.strokeStyle = '#f1c40f'; ctx.lineWidth = 3; ctx.strokeRect(col2Center - 100, 250, 200, 50);
            ctx.fillStyle = '#f1c40f'; ctx.font = '30px "Press Start 2P"'; ctx.fillText(winnerName + (frameCount % 60 < 30 ? "_" : ""), col2Center, 290);
            ctx.fillStyle = '#bdc3c7'; ctx.font = '16px Noto Sans TC'; ctx.fillText("Êåâ Enter Á¢∫Ë™ç", col2Center, 350);
        } else {
            ctx.fillStyle = '#f1c40f'; ctx.font = '24px Noto Sans TC'; ctx.fillText("üèÜ ÊéíË°åÊ¶ú üèÜ", col2Center, 100);
            let scores = JSON.parse(localStorage.getItem(LEADERBOARD_KEY) || "[]");
            ctx.font = '16px Noto Sans TC'; ctx.fillStyle = 'white';
            for(let i=0; i<Math.min(10, scores.length); i++) {
                let y = 150 + i * 30;
                ctx.textAlign = 'right'; ctx.fillText(`${i+1}.`, col2Center - 60, y);
                ctx.textAlign = 'left'; ctx.fillText(scores[i].name, col2Center - 40, y);
                ctx.textAlign = 'right'; ctx.fillText(scores[i].score, col2Center + 80, y);
            }
            ctx.textAlign = 'center'; ctx.fillStyle = '#ecf0f1'; ctx.font = '20px Noto Sans TC'; ctx.fillText("Êåâ [Á©∫ÁôΩÈçµ] ËøîÂõû‰∏ªÈÅ∏ÂñÆ", col2Center, 550);
        }
    }
}

function loop() {
    update(); draw(); requestAnimationFrame(loop);
}

function resize() {
    let scale = Math.min(window.innerWidth / GAME_WIDTH, window.innerHeight / GAME_HEIGHT);
    canvas.style.width = (GAME_WIDTH * scale) + 'px';
    canvas.style.height = (GAME_HEIGHT * scale) + 'px';
}
window.addEventListener('resize', resize);
resize();
loop();
</script>
</body>
</html>
