<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è…¦åŠ›å¤§äº‚é¬¥ï¼šé›™äººå¥§æ•¸ç«¶æŠ€å ´</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Noto+Sans+TC:wght@700&display=swap');

        body {
            margin: 0;
            padding: 0;
            background-color: #2c3e50;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            font-family: 'Noto Sans TC', sans-serif;
            color: white;
            user-select: none;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 30px rgba(0,0,0,0.6);
            border: 4px solid #f1c40f;
            border-radius: 8px;
            background-color: #34495e;
        }

        canvas {
            display: block;
        }

        .mobile-warning {
            display: none;
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            color: white;
            z-index: 999;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 20px;
            font-size: 1.2rem;
        }

        @media (hover: none) and (pointer: coarse) {
            .mobile-warning { display: flex; }
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div class="mobile-warning">è«‹ä½¿ç”¨é›»è…¦éµç›¤é€²è¡Œé›™äººå°æˆ°ä»¥ç²å¾—æœ€ä½³é«”é©—ã€‚</div>
</div>

<script>
/**
 * è…¦åŠ›å¤§äº‚é¬¥ v2.0
 * æ›´æ–°ï¼šå¹¾ä½•åœ–å½¢ç”Ÿæˆã€ç©æœ¨é¡¯ç¤ºä¿®å¾©ã€å¥ªå¯¶çµåˆæ•¸å­¸é¡Œã€UIç½®ä¸­
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// --- å…¨å±€è®Šæ•¸ ---
const GAME_WIDTH = 800;
const GAME_HEIGHT = 600;

const STATE = {
    MENU: 0,
    INSTRUCTION: 1,
    PLAYING: 2,
    ROUND_END: 3,
    GAME_OVER: 4
};

let currentState = STATE.MENU;
let frameCount = 0;
let totalTime = 60;
let timeRemaining = 0; // ç”¨æ–¼å€’è¨ˆæ™‚

// ç©å®¶é…ç½®
const p1 = { score: 0, color: '#3498db', name: 'Player 1', emoji: 'ğŸ¤–', lastKey: null, lastKeyTime: 0, dash: false, stun: 0 };
const p2 = { score: 0, color: '#e74c3c', name: 'Player 2', emoji: 'ğŸ¦–', lastKey: null, lastKeyTime: 0, dash: false, stun: 0 };

const keys = {};
let currentMode = null;
let lastModeIndex = -1;
let roundWinner = null;
let roundInstruction = "";
let difficultyLevel = 1;

const LEADERBOARD_KEY = 'math_battle_ranking_v2';

// --- å·¥å…·å‡½æ•¸ ---

function randomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

function rectIntersect(x1, y1, w1, h1, x2, y2, w2, h2) {
    return x2 < x1 + w1 && x2 + w2 > x1 && y2 < y1 + h1 && y2 + h2 > y1;
}

function circleIntersect(x1, y1, r1, x2, y2, r2) {
    let dist = Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2);
    return dist < r1 + r2;
}

function drawEmoji(emoji, x, y, size) {
    ctx.font = `${size}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(emoji, x, y);
}

// ç¹ªè£½åœ“è§’çŸ©å½¢èƒŒæ™¯ (ç”¨æ–¼æ–‡å­—è¥¯åº•)
function drawTextBg(x, y, text, fontSize, padding=10) {
    ctx.font = `${fontSize}px Noto Sans TC`;
    let width = ctx.measureText(text).width + padding * 2;
    let height = fontSize + padding;
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(x - width/2, y - height/2, width, height);
}

// --- è¼¸å…¥è™•ç† ---
window.addEventListener('keydown', (e) => {
    if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight", "Space"].indexOf(e.code) > -1) {
        e.preventDefault();
    }
    const key = e.key.toLowerCase();
    const now = Date.now();
    let player = null;

    if (['w','a','s','d'].includes(key)) player = p1;
    if (['arrowup','arrowdown','arrowleft','arrowright'].includes(key)) player = p2;

    if (player && player.stun <= 0) {
        if (player.lastKey === key && now - player.lastKeyTime < 300) {
            player.dash = true; 
        }
        player.lastKey = key;
        player.lastKeyTime = now;
    }

    keys[key] = true;
});

window.addEventListener('keyup', (e) => {
    const key = e.key.toLowerCase();
    keys[key] = false;
    if (['w','a','s','d'].includes(key)) p1.dash = false;
    if (['arrowup','arrowdown','arrowleft','arrowright'].includes(key)) p2.dash = false;
});

// --- é¡Œç›®ç”Ÿæˆå™¨ ---
function generateProblem(forceType = -1) {
    const difficulty = Math.min(1, (60 - totalTime) / 50); 
    let type = forceType !== -1 ? forceType : (difficulty < 0.4 ? 0 : (Math.random() > 0.6 ? 2 : 1));

    let q = "", a = 0, options = [];

    if (type === 0) { // åŠ æ¸›
        let max = 10 + Math.floor(difficulty * 40);
        let n1 = randomInt(1, max);
        let n2 = randomInt(1, max);
        if (Math.random() > 0.5) {
            q = `${n1} + ${n2} = ?`;
            a = n1 + n2;
        } else {
            let big = Math.max(n1, n2);
            let small = Math.min(n1, n2);
            q = `${big} - ${small} = ?`;
            a = big - small;
        }
    } else if (type === 1) { // ä¹˜æ³•
        let maxMulti = 3 + Math.floor(difficulty * 9); 
        let n1 = randomInt(2, maxMulti);
        let n2 = randomInt(2, maxMulti);
        q = `${n1} Ã— ${n2} = ?`;
        a = n1 * n2;
    } else { // æ•¸åˆ—
        let start = randomInt(1, 10);
        let step = randomInt(2, 5);
        let idx = randomInt(2, 4); 
        let seq = [];
        for(let i=0; i<5; i++) seq.push(start + i*step);
        a = seq[idx];
        seq[idx] = '?';
        q = seq.join(', ');
    }

    while(options.length < 3) {
        let offset = randomInt(-5, 5);
        if (offset === 0) continue;
        let wrong = a + offset;
        if (wrong < 0) wrong = Math.abs(wrong);
        if (wrong !== a && !options.includes(wrong)) options.push(wrong);
    }
    options.push(a);
    options.sort(() => Math.random() - 0.5);
    return { text: q, answer: a, options: options };
}

// --- éŠæˆ²æ¨¡å¼é¡åˆ¥ ---
class GameMode {
    constructor() {
        this.winner = null;
        this.problem = generateProblem();
    }
    init() {}
    update() {}
    draw() {}
    checkWin(player) {
        if (!this.winner) {
            this.winner = player;
            player.score += 100;
            setTimeout(() => { if (currentState === STATE.PLAYING) endGameRound(player); }, 500); 
        } else if (this.winner !== player) {
             player.score += 50;
        }
    }
}

// Mode 1: ç‚®å°å°„æ“Š (ä¿æŒä¸è®Šï¼Œç•¥å¾®å„ªåŒ–é€Ÿåº¦)
class ShooterMode extends GameMode {
    constructor() {
        super();
        this.bullets = [];
        this.targets = []; 
        this.p1Angle = 0; this.p2Angle = 0;
        this.p1Cooldown = 0; this.p2Cooldown = 0;
    }

    init() {
        this.problem.options.forEach(opt => {
            this.targets.push({
                x: randomInt(100, 700), y: randomInt(50, 250),
                vx: (Math.random() - 0.5) * 4, vy: (Math.random() - 0.5) * 4,
                val: opt, r: 25,
                type: opt === this.problem.answer ? 'correct' : 'wrong'
            });
        });
        this.walls = [{x: 350, y: 300, w: 100, h: 20}, {x: 100, y: 150, w: 20, h: 100}, {x: 680, y: 150, w: 20, h: 100}];
    }

    update() {
        // P1 Control
        if (keys['a']) this.p1Angle -= 0.08;
        if (keys['d']) this.p1Angle += 0.08;
        this.p1Angle = Math.max(-1.5, Math.min(1.5, this.p1Angle));
        if (keys['w'] && this.p1Cooldown <= 0) {
            this.bullets.push({x: 100, y: 550, vx: Math.sin(this.p1Angle)*12, vy: -Math.cos(this.p1Angle)*12, owner: p1, life: 100});
            this.p1Cooldown = 20;
        }

        // P2 Control
        if (keys['arrowleft']) this.p2Angle -= 0.08;
        if (keys['arrowright']) this.p2Angle += 0.08;
        this.p2Angle = Math.max(-1.5, Math.min(1.5, this.p2Angle));
        if (keys['arrowup'] && this.p2Cooldown <= 0) {
            this.bullets.push({x: 700, y: 550, vx: Math.sin(this.p2Angle)*12, vy: -Math.cos(this.p2Angle)*12, owner: p2, life: 100});
            this.p2Cooldown = 20;
        }

        if (this.p1Cooldown > 0) this.p1Cooldown--;
        if (this.p2Cooldown > 0) this.p2Cooldown--;

        // Targets Move
        this.targets.forEach(t => {
            t.x += t.vx; t.y += t.vy;
            if (t.x < t.r || t.x > GAME_WIDTH - t.r) t.vx *= -1;
            if (t.y < t.r || t.y > 400) t.vy *= -1;
        });

        // Bullet Logic
        for (let i = this.bullets.length - 1; i >= 0; i--) {
            let b = this.bullets[i];
            b.x += b.vx; b.y += b.vy; b.life--;
            if (b.x < 0 || b.x > GAME_WIDTH) b.vx *= -1;
            if (b.y < 0) b.vy *= -1; 
            this.walls.forEach(w => { if (rectIntersect(b.x, b.y, 5, 5, w.x, w.y, w.w, w.h)) b.vy *= -1; });

            for (let t of this.targets) {
                if (circleIntersect(b.x, b.y, 5, t.x, t.y, t.r)) {
                    if (t.type === 'correct') this.checkWin(b.owner);
                    else b.life = 0; 
                    this.bullets.splice(i, 1);
                    break;
                }
            }
            if (b.life <= 0 || b.y > 600) this.bullets.splice(i, 1);
        }
    }

    draw() {
        ctx.fillStyle = 'white';
        ctx.font = '30px Noto Sans TC';
        ctx.textAlign = 'center';
        ctx.fillText(`å°„æ“Šæ­£ç¢ºç­”æ¡ˆ: ${this.problem.text}`, GAME_WIDTH/2, 50);

        this.targets.forEach(t => {
            ctx.fillStyle = '#ecf0f1';
            ctx.beginPath(); ctx.arc(t.x, t.y, t.r, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#2c3e50'; ctx.font = 'bold 20px Arial'; ctx.textBaseline = 'middle'; ctx.fillText(t.val, t.x, t.y);
        });

        ctx.fillStyle = '#7f8c8d';
        this.walls.forEach(w => { ctx.fillRect(w.x, w.y, w.w, w.h); drawEmoji('ğŸ§±', w.x + w.w/2, w.y + w.h/2, 20); });

        // Draw Turrets
        const drawTurret = (x, angle, emoji) => {
            ctx.save(); ctx.translate(x, 550); ctx.rotate(angle);
            drawEmoji('ğŸš€', 0, 0, 50); ctx.restore();
            drawEmoji(emoji, x, 580, 30);
        };
        drawTurret(100, this.p1Angle, p1.emoji);
        drawTurret(700, this.p2Angle, p2.emoji);

        this.bullets.forEach(b => drawEmoji('ğŸ”¹', b.x, b.y, 15));
    }
}

// Mode 2: æ•¸å¹¾ä½•åœ–å½¢ (å¥§æ•¸é¢¨æ ¼)
class GeometryMode extends GameMode {
    constructor() {
        super();
        this.problem.text = "åœ–ä¸­å…±æœ‰å¤šå°‘å€‹ä¸‰è§’å½¢ï¼Ÿ";
        
        // ç”Ÿæˆå¥§æ•¸ä¸‰è§’å½¢é‚è¼¯
        // ä¸€å€‹å¤§ä¸‰è§’å½¢ï¼Œå¾é ‚é»å‘ä¸‹å¼•å‡º lines æ¢ç·š (åˆ†å‰²æˆ lines+1 å€‹å€å¡Š)
        // æ©«å‘æœ‰ layers æ¢ç·š (åˆ†å‰²æˆ layers+1 å±¤)
        // ç¸½æ•¸å…¬å¼ = (base_sections * (base_sections + 1) / 2) * horizontal_layers
        
        let segments = randomInt(2, 5); // åº•é‚Šåˆ†æ®µæ•¸
        let layers = randomInt(1, 3);   // æ©«å‘å±¤æ•¸ (1 = åªæœ‰åº•é‚Š, 2 = ä¸­é–“å¤šä¸€æ¢æ©«ç·š)
        
        this.count = (segments * (segments + 1) / 2) * layers;
        this.problem.answer = this.count;
        this.structure = { segments: segments, layers: layers };

        // é¸é …ç”Ÿæˆ
        this.options = { 'Up': 0, 'Down': 0, 'Left': 0, 'Right': 0 };
        let keys = Object.keys(this.options);
        let correctKey = keys[randomInt(0, 3)];
        
        keys.forEach(k => {
            if (k === correctKey) this.options[k] = this.count;
            else {
                let n = this.count + randomInt(-3, 3);
                while (n === this.count || n <= 0) n = this.count + randomInt(-4, 4);
                this.options[k] = n;
            }
        });
    }

    update() {
        if (keys['w']) this.checkAnswer(p1, 'Up');
        else if (keys['s']) this.checkAnswer(p1, 'Down');
        else if (keys['a']) this.checkAnswer(p1, 'Left');
        else if (keys['d']) this.checkAnswer(p1, 'Right');

        if (keys['arrowup']) this.checkAnswer(p2, 'Up');
        else if (keys['arrowdown']) this.checkAnswer(p2, 'Down');
        else if (keys['arrowleft']) this.checkAnswer(p2, 'Left');
        else if (keys['arrowright']) this.checkAnswer(p2, 'Right');
    }

    checkAnswer(player, dir) {
        if (this.winner === player) return;
        if (player.lock) return;

        if (this.options[dir] === this.problem.answer) {
            this.checkWin(player);
        } else {
            player.score = Math.max(0, player.score - 10);
            player.lock = true;
            setTimeout(() => player.lock = false, 500); // ç°¡å–®æ‡²ç½°
        }
    }

    draw() {
        ctx.fillStyle = 'white';
        ctx.font = '30px Noto Sans TC';
        ctx.textAlign = 'center';
        ctx.fillText(this.problem.text, GAME_WIDTH/2, 60);

        // ç¹ªè£½å¥§æ•¸ä¸‰è§’å½¢
        const topX = GAME_WIDTH / 2;
        const topY = 150;
        const baseY = 450;
        const baseWidth = 300;
        const leftX = topX - baseWidth / 2;
        const rightX = topX + baseWidth / 2;

        ctx.strokeStyle = '#f1c40f';
        ctx.lineWidth = 4;
        ctx.lineJoin = 'round';

        // 1. ç•«å¤–æ¡†
        ctx.beginPath();
        ctx.moveTo(topX, topY);
        ctx.lineTo(leftX, baseY);
        ctx.lineTo(rightX, baseY);
        ctx.closePath();
        ctx.stroke();

        // 2. ç•«é ‚é»æ”¾å°„ç·š
        let segs = this.structure.segments;
        for (let i = 1; i < segs; i++) {
            let ratio = i / segs;
            let targetX = leftX + (baseWidth * ratio);
            ctx.beginPath();
            ctx.moveTo(topX, topY);
            ctx.lineTo(targetX, baseY);
            ctx.stroke();
        }

        // 3. ç•«æ©«åˆ‡ç·š
        let lays = this.structure.layers; // å¯¦éš›å±¤æ•¸ (åŒ…å«åº•é‚Š)
        // å¦‚æœ layers = 2, ä»£è¡¨ä¸­é–“æœ‰ä¸€æ¢ç·šï¼Œç¸½å…± 2 å±¤ä¸‰è§’å½¢
        for (let i = 1; i < lays; i++) {
            let ratio = i / lays;
            // åˆ©ç”¨ç›¸ä¼¼ä¸‰è§’å½¢åŸç†è¨ˆç®—æ©«ç·šç«¯é»
            let ly = topY + (baseY - topY) * ratio;
            let lx = topX - (baseWidth / 2) * ratio;
            let rx = topX + (baseWidth / 2) * ratio;
            
            ctx.beginPath();
            ctx.moveTo(lx, ly);
            ctx.lineTo(rx, ly);
            ctx.stroke();
        }

        // é¸é … UI
        this.drawOptionText(this.options.Up, GAME_WIDTH/2, 110, 'â†‘ W');
        this.drawOptionText(this.options.Down, GAME_WIDTH/2, 550, 'â†“ S');
        this.drawOptionText(this.options.Left, 100, 300, 'â† A');
        this.drawOptionText(this.options.Right, 700, 300, 'â†’ D');
    }

    drawOptionText(val, x, y, keyHint) {
        ctx.beginPath(); ctx.arc(x, y, 35, 0, Math.PI*2); ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fill();
        ctx.fillStyle = '#f1c40f'; ctx.font = 'bold 30px Arial'; ctx.textAlign = 'center'; ctx.fillText(val, x, y);
        ctx.fillStyle = '#bdc3c7'; ctx.font = '14px Arial'; ctx.fillText(keyHint, x, y + 50);
    }
}

// Mode 3: æ•¸ç©æœ¨ (ä¿®å¾©é®æ“‹å•é¡Œ + é™åˆ¶15å€‹)
class CubeMode extends GeometryMode {
    constructor() {
        super();
        this.problem.text = "æ•¸æ•¸æœ‰å¤šå°‘å€‹ç©æœ¨ï¼Ÿ";
        this.cubes = [];
        
        let totalCubes = 0;
        let attempts = 0;

        // å˜—è©¦ç”Ÿæˆç¬¦åˆ <= 15 å€‹çš„ç©æœ¨é…ç½®
        while (true) {
            this.cubes = [];
            totalCubes = 0;
            // ä½¿ç”¨ 3x3 ç¶²æ ¼
            for(let x=0; x<3; x++) {
                for(let y=0; y<3; y++) {
                    let h = randomInt(0, 3); // éš¨æ©Ÿé«˜åº¦
                    // ç¢ºä¿ä¸æœƒå®Œå…¨ç©ºç™½
                    if(x===1 && y===1 && h===0) h=1; 
                    
                    for(let z=0; z<h; z++) {
                        this.cubes.push({gx: x, gy: y, gz: z});
                    }
                    totalCubes += h;
                }
            }
            if (totalCubes > 1 && totalCubes <= 15) break; // æ¢ä»¶é”æˆ
            attempts++;
            if (attempts > 100) break; // é˜²æ­¢æ­»å¾ªç’°
        }
        
        this.problem.answer = totalCubes;
        
        // é‡æ–°ç”Ÿæˆé¸é …
        this.options = { 'Up': 0, 'Down': 0, 'Left': 0, 'Right': 0 };
        let keys = Object.keys(this.options);
        let correctKey = keys[randomInt(0, 3)];
        keys.forEach(k => {
            if (k === correctKey) this.options[k] = totalCubes;
            else {
                let n = totalCubes + randomInt(-3, 3);
                while (n === totalCubes || n <= 0) n = totalCubes + randomInt(-4, 4);
                this.options[k] = n;
            }
        });
    }

    draw() {
        ctx.fillStyle = 'white';
        ctx.font = '30px Noto Sans TC';
        ctx.textAlign = 'center';
        ctx.fillText(this.problem.text, GAME_WIDTH/2, 60);

        let originX = GAME_WIDTH / 2;
        let originY = 280;
        let size = 50;

        // é—œéµä¿®å¾©ï¼šæ­£ç¢ºçš„ Isometric æ’åº (Painter's Algorithm)
        // é †åºï¼šå…ˆç•«å¾Œé¢çš„ (x+y è¼ƒå°)ï¼Œå¦‚æœ x+y ä¸€æ¨£ï¼Œç•«ä¸‹é¢çš„ (gz è¼ƒå°)
        this.cubes.sort((a, b) => {
            let depthA = a.gx + a.gy;
            let depthB = b.gx + b.gy;
            if (depthA !== depthB) return depthA - depthB;
            return a.gz - b.gz;
        });

        this.cubes.forEach(c => {
            // ç­‰è»¸æ¸¬æŠ•å½±å…¬å¼
            let x = (c.gx - c.gy) * size + originX;
            let y = (c.gx + c.gy) * size * 0.5 - (c.gz * size) + originY;
            this.drawCube(x, y, size);
        });

        // UI
        this.drawOptionText(this.options.Up, GAME_WIDTH/2, 110, 'â†‘ W');
        this.drawOptionText(this.options.Down, GAME_WIDTH/2, 550, 'â†“ S');
        this.drawOptionText(this.options.Left, 100, 300, 'â† A');
        this.drawOptionText(this.options.Right, 700, 300, 'â†’ D');
    }

    drawCube(x, y, size) {
        // Top
        ctx.fillStyle = '#e74c3c'; ctx.beginPath();
        ctx.moveTo(x, y - size); ctx.lineTo(x + size, y - size * 1.5);
        ctx.lineTo(x, y - size * 2); ctx.lineTo(x - size, y - size * 1.5);
        ctx.fill(); ctx.stroke();
        // Right
        ctx.fillStyle = '#c0392b'; ctx.beginPath();
        ctx.moveTo(x, y - size); ctx.lineTo(x + size, y - size * 1.5);
        ctx.lineTo(x + size, y - size * 0.5); ctx.lineTo(x, y);
        ctx.fill(); ctx.stroke();
        // Left
        ctx.fillStyle = '#e67e22'; ctx.beginPath();
        ctx.moveTo(x, y - size); ctx.lineTo(x - size, y - size * 1.5);
        ctx.lineTo(x - size, y - size * 0.5); ctx.lineTo(x, y);
        ctx.fill(); ctx.stroke();
    }
}

// Mode 4: å¥ªå¯¶è¿½é€ (çµåˆæ•¸å­¸è¨ˆç®—)
class ChaseMode extends GameMode {
    constructor() {
        super();
        this.problem = generateProblem(); // ç”Ÿæˆæ•¸å­¸é¡Œ
        this.problem.text = "ç®—å‡ºç­”æ¡ˆä¸¦æ¶å¥ªï¼" + this.problem.text;
        
        this.holder = null;
        this.holdTime = 0;
        this.targetTime = 180; // 3ç§’
        
        this.items = []; // å­˜æ”¾ç­”æ¡ˆçƒ
        
        // ç”Ÿæˆ 3 å€‹ç­”æ¡ˆçƒ (1å°2éŒ¯)
        let answers = this.problem.options.slice(0, 3); // å–å‰3å€‹é¸é …
        answers.forEach((ans, i) => {
            this.items.push({
                x: randomInt(100, 700),
                y: randomInt(100, 500),
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2,
                val: ans,
                isCorrect: (ans === this.problem.answer)
            });
        });

        this.p1Pos = { x: 150, y: 300, cooldown: 0 };
        this.p2Pos = { x: 650, y: 300, cooldown: 0 };
    }

    update() {
        this.movePlayer(this.p1Pos, 'w', 's', 'a', 'd', p1);
        this.movePlayer(this.p2Pos, 'arrowup', 'arrowdown', 'arrowleft', 'arrowright', p2);

        // ç‰©å“ç‰©ç†
        this.items.forEach(item => {
            // å¦‚æœè¢«æŒæœ‰ï¼Œåº§æ¨™è·Ÿéš¨ç©å®¶
            if (this.holder && item.isCorrect) {
                 let pos = this.holder === p1 ? this.p1Pos : this.p2Pos;
                 item.x = pos.x;
                 item.y = pos.y - 45;
            } else {
                // è‡ªç„¶é£„å‹•
                item.x += item.vx; item.y += item.vy;
                if(item.x < 30 || item.x > GAME_WIDTH-30) item.vx *= -1;
                if(item.y < 30 || item.y > GAME_HEIGHT-30) item.vy *= -1;
            }
        });

        // æª¢æ¸¬æ‹¾å–èˆ‡æ‡²ç½°
        if (!this.holder) {
            this.checkPickUp(p1, this.p1Pos);
            this.checkPickUp(p2, this.p2Pos);
        } else {
            this.holdTime++;
            if (this.holdTime >= this.targetTime) this.checkWin(this.holder);
        }

        // è¡åˆºæ¶å¥ª
        this.checkCollisions();
        
        // æšˆçœ©è¨ˆæ™‚
        if(p1.stun > 0) p1.stun--;
        if(p2.stun > 0) p2.stun--;
    }

    checkPickUp(player, pos) {
        if (player.stun > 0) return;
        
        for (let item of this.items) {
            if (circleIntersect(pos.x, pos.y, 30, item.x, item.y, 30)) {
                if (item.isCorrect) {
                    this.holder = player;
                } else {
                    // æ¶éŒ¯äº†ï¼æšˆçœ©
                    player.stun = 60; // 1ç§’
                    // æ¨é–‹ä¸€é»é¿å…é€£çºŒåˆ¤å®š
                    pos.x -= item.vx * 10;
                }
            }
        }
    }

    movePlayer(pos, u, d, l, r, playerRef) {
        if (playerRef.stun > 0) return; // æšˆçœ©ä¸­ä¸èƒ½å‹•

        let speed = 5;
        if (this.holder === playerRef) speed = 4; // æŒæœ‰æ¸›é€Ÿ

        if (playerRef.dash && pos.cooldown <= 0) {
            speed = 12; pos.cooldown = 15;
        }
        if (pos.cooldown > 0) { pos.cooldown--; speed = 12; }

        if (keys[u]) pos.y -= speed;
        if (keys[d]) pos.y += speed;
        if (keys[l]) pos.x -= speed;
        if (keys[r]) pos.x += speed;

        pos.x = Math.max(30, Math.min(GAME_WIDTH - 30, pos.x));
        pos.y = Math.max(30, Math.min(GAME_HEIGHT - 30, pos.y));
    }

    checkCollisions() {
        if (circleIntersect(this.p1Pos.x, this.p1Pos.y, 30, this.p2Pos.x, this.p2Pos.y, 30)) {
            let p1Dashing = p1.dash;
            let p2Dashing = p2.dash;

            if (p1Dashing && this.holder === p2) {
                this.holder = null; this.holdTime = 0;
            } 
            else if (p2Dashing && this.holder === p1) {
                this.holder = null; this.holdTime = 0;
            }
        }
    }

    draw() {
        ctx.fillStyle = 'white';
        ctx.font = '30px Noto Sans TC';
        ctx.textAlign = 'center';
        // é¡¯ç¤ºç®—å¼
        let probPart = this.problem.text.split("ï¼")[1] || this.problem.text;
        ctx.fillText(`ç®—å‡º ${probPart} ä¸¦æ¶å¥ªï¼`, GAME_WIDTH/2, 50);

        // ç©å®¶
        const drawPlayer = (p, pos) => {
            drawEmoji(p.emoji, pos.x, pos.y, 50);
            if (p.stun > 0) drawEmoji('ğŸ’«', pos.x, pos.y - 30, 30);
            if (p.dash) drawEmoji('ğŸ’¨', pos.x - 20, pos.y, 30);
        };
        drawPlayer(p1, this.p1Pos);
        drawPlayer(p2, this.p2Pos);

        // ç‰©å“
        this.items.forEach(item => {
            ctx.beginPath(); ctx.arc(item.x, item.y, 30, 0, Math.PI*2);
            ctx.fillStyle = '#f39c12'; ctx.fill();
            ctx.stroke();
            ctx.fillStyle = 'white'; ctx.font = 'bold 24px Arial';
            ctx.fillText(item.val, item.x, item.y);
            // å¦‚æœæ˜¯æ­£ç¢ºç­”æ¡ˆä¸”æ²’äººæŒæœ‰ï¼Œç•«å€‹å…‰åœˆæç¤º(å¯é¸ï¼Œé€™è£¡ä¸ç•«å¢åŠ é›£åº¦)
        });

        // é€²åº¦æ¢
        if (this.holder) {
            ctx.fillStyle = this.holder.color;
            let w = (this.holdTime / this.targetTime) * 300;
            ctx.fillRect(GAME_WIDTH/2 - 150, 80, w, 20);
            ctx.strokeStyle = 'white'; ctx.lineWidth = 2;
            ctx.strokeRect(GAME_WIDTH/2 - 150, 80, 300, 20);
        }
    }
}

// Mode 5: æ•¸å­—é›¨ (ä¿æŒä¸è®Š)
class RainMode extends GameMode {
    constructor() {
        super();
        this.items = []; this.spawnTimer = 0;
        this.p1X = 200; this.p2X = 600;
        // ç°¡å–®é©é…é¡Œç›®
        if(this.problem.text.includes(',')) this.problem = generateProblem(0); 
    }

    update() {
        if (keys['a']) this.p1X -= 8;
        if (keys['d']) this.p1X += 8;
        if (keys['arrowleft']) this.p2X -= 8;
        if (keys['arrowright']) this.p2X += 8;

        this.p1X = Math.max(30, Math.min(GAME_WIDTH - 30, this.p1X));
        this.p2X = Math.max(30, Math.min(GAME_WIDTH - 30, this.p2X));

        this.spawnTimer++;
        if (this.spawnTimer > 40) {
            this.spawnTimer = 0;
            let r = Math.random();
            let type = 'wrong'; let val = 0;
            if (r > 0.7) { type = 'correct'; val = this.problem.answer; }
            else if (r < 0.2) { type = 'bomb'; val = ''; }
            else { val = this.problem.answer + randomInt(1, 10) * (Math.random()>0.5?1:-1); }

            this.items.push({ x: randomInt(30, GAME_WIDTH - 30), y: -30, type: type, val: val, speed: 3 + Math.random() * 3 });
        }

        for (let i = this.items.length - 1; i >= 0; i--) {
            let item = this.items[i]; item.y += item.speed;
            if (Math.abs(item.x - this.p1X) < 40 && Math.abs(item.y - 550) < 40) { this.handleCatch(p1, item, i); continue; }
            if (Math.abs(item.x - this.p2X) < 40 && Math.abs(item.y - 550) < 40) { this.handleCatch(p2, item, i); continue; }
            if (item.y > GAME_HEIGHT) this.items.splice(i, 1);
        }
    }

    handleCatch(player, item, index) {
        this.items.splice(index, 1);
        if (item.type === 'correct') this.checkWin(player);
        else if (item.type === 'bomb') player.score = Math.max(0, player.score - 50);
        else player.score = Math.max(0, player.score - 10);
    }

    draw() {
        ctx.fillStyle = 'white'; ctx.font = '30px Noto Sans TC'; ctx.textAlign = 'center';
        ctx.fillText(`æ¥ä½æ­£ç¢ºç­”æ¡ˆ: ${this.problem.text}`, GAME_WIDTH/2, 50);
        drawEmoji(p1.emoji, this.p1X, 550, 60);
        drawEmoji(p2.emoji, this.p2X, 550, 60);

        this.items.forEach(item => {
            if (item.type === 'bomb') drawEmoji('ğŸ’£', item.x, item.y, 40);
            else {
                ctx.fillStyle = item.type === 'correct' ? '#f1c40f' : '#ecf0f1';
                ctx.beginPath(); ctx.arc(item.x, item.y, 25, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = 'black'; ctx.font = '20px Arial'; ctx.fillText(item.val, item.x, item.y);
            }
        });
    }
}

// --- æµç¨‹æ§åˆ¶ ---

function startNewGame() {
    p1.score = 0; p2.score = 0;
    p1.stun = 0; p2.stun = 0;
    totalTime = 60;
    lastModeIndex = -1;
    currentState = STATE.MENU;
}

function selectNextMode() {
    const modes = [ShooterMode, GeometryMode, CubeMode, ChaseMode, RainMode];
    let nextIndex = randomInt(0, 4);
    while (nextIndex === lastModeIndex) nextIndex = randomInt(0, 4);
    lastModeIndex = nextIndex;
    
    currentMode = new modes[nextIndex]();
    currentMode.init();
    
    const instructions = ["å°„æ“Šæ­£ç¢ºç­”æ¡ˆï¼", "æ•¸æ•¸ä¸‰è§’å½¢ï¼", "æ•¸æ•¸ç©æœ¨ï¼", "ç®—å‡ºç­”æ¡ˆä¸¦æ¶å¥ªï¼", "æ¥ä½æ­£ç¢ºç­”æ¡ˆï¼"];
    roundInstruction = instructions[nextIndex];
    
    currentState = STATE.INSTRUCTION;
    timeRemaining = 120; 
}

function endGameRound(winner) {
    roundWinner = winner;
    currentState = STATE.ROUND_END;
    timeRemaining = 60; 
}

function update() {
    frameCount++;
    if (currentState === STATE.MENU) {
        if (keys[' ']) { totalTime = 60; p1.score = 0; p2.score = 0; selectNextMode(); }
    } else if (currentState === STATE.INSTRUCTION) {
        timeRemaining--;
        if (timeRemaining <= 0) currentState = STATE.PLAYING;
    } else if (currentState === STATE.PLAYING) {
        if (frameCount % 60 === 0) totalTime--;
        if (totalTime <= 0) { saveScore(); currentState = STATE.GAME_OVER; }
        currentMode.update();
    } else if (currentState === STATE.ROUND_END) {
        timeRemaining--;
        if (timeRemaining <= 0) selectNextMode();
    } else if (currentState === STATE.GAME_OVER) {
        if (keys[' ']) startNewGame();
    }
}

function draw() {
    ctx.fillStyle = '#2c3e50';
    ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

    if (currentState === STATE.MENU) {
        ctx.fillStyle = 'white'; ctx.textAlign = 'center';
        ctx.font = '50px "Press Start 2P"'; ctx.fillText("è…¦åŠ›å¤§äº‚é¬¥", GAME_WIDTH/2, 180);
        ctx.font = '24px Noto Sans TC'; ctx.fillText("æŒ‰ [ç©ºç™½éµ] é–‹å§‹éŠæˆ²", GAME_WIDTH/2, 280);
        
        ctx.textAlign = 'left';
        ctx.fillStyle = p1.color; ctx.fillText(`${p1.emoji} ç©å®¶ 1: WASD`, 180, 380);
        ctx.fillStyle = p2.color; ctx.fillText(`${p2.emoji} ç©å®¶ 2: æ–¹å‘éµ`, 480, 380);
        
        drawLeaderboard();

    } else if (currentState === STATE.INSTRUCTION) {
        ctx.fillStyle = '#f1c40f'; ctx.font = 'bold 60px Noto Sans TC'; ctx.textAlign = 'center';
        ctx.fillText(roundInstruction, GAME_WIDTH/2, GAME_HEIGHT/2);
        
    } else if (currentState === STATE.PLAYING) {
        currentMode.draw();
        
        // HUD
        ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(0, 0, GAME_WIDTH, 40); 
        ctx.textAlign = 'center'; ctx.fillStyle = totalTime < 10 ? '#e74c3c' : 'white';
        ctx.font = '20px "Press Start 2P"'; ctx.fillText(`TIME: ${totalTime}`, GAME_WIDTH/2, 28);

        ctx.textAlign = 'left'; ctx.fillStyle = p1.color; ctx.fillText(`${p1.emoji} ${p1.score}`, 20, 28);
        ctx.textAlign = 'right'; ctx.fillStyle = p2.color; ctx.fillText(`${p2.score} ${p2.emoji}`, GAME_WIDTH - 20, 28);

    } else if (currentState === STATE.ROUND_END) {
        currentMode.draw();
        ctx.fillStyle = 'rgba(0,0,0,0.7)'; ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
        ctx.fillStyle = 'white'; ctx.font = '60px Noto Sans TC'; ctx.textAlign = 'center';
        if (roundWinner) {
            ctx.fillText(`${roundWinner.emoji} ç²å‹!`, GAME_WIDTH/2, GAME_HEIGHT/2);
            ctx.font = '30px Arial'; ctx.fillStyle = '#f1c40f'; ctx.fillText("+100 åˆ†", GAME_WIDTH/2, GAME_HEIGHT/2 + 50);
        } else ctx.fillText("æ™‚é–“åˆ°!", GAME_WIDTH/2, GAME_HEIGHT/2);

    } else if (currentState === STATE.GAME_OVER) {
        ctx.fillStyle = 'white'; ctx.font = '50px "Press Start 2P"'; ctx.textAlign = 'center';
        ctx.fillText("GAME OVER", GAME_WIDTH/2, 120);
        
        ctx.font = '40px Noto Sans TC';
        ctx.fillStyle = p1.color; ctx.fillText(`P1: ${p1.score}`, GAME_WIDTH/2, 220);
        ctx.fillStyle = p2.color; ctx.fillText(`P2: ${p2.score}`, GAME_WIDTH/2, 280);

        let wText = p1.score > p2.score ? "Player 1 å‹åˆ©!" : (p2.score > p1.score ? "Player 2 å‹åˆ©!" : "å¹³æ‰‹!");
        ctx.fillStyle = '#f1c40f'; ctx.font = 'bold 50px Noto Sans TC'; ctx.fillText(wText, GAME_WIDTH/2, 380);
        ctx.fillStyle = 'white'; ctx.font = '20px Noto Sans TC'; ctx.fillText("æŒ‰ [ç©ºç™½éµ] é‡æ–°é–‹å§‹", GAME_WIDTH/2, 500);
    }
}

function saveScore() {
    let scores = JSON.parse(localStorage.getItem(LEADERBOARD_KEY) || "[]");
    if(p1.score > 0) scores.push({name: "P1", score: p1.score});
    if(p2.score > 0) scores.push({name: "P2", score: p2.score});
    scores.sort((a, b) => b.score - a.score);
    if(scores.length > 5) scores = scores.slice(0, 5);
    localStorage.setItem(LEADERBOARD_KEY, JSON.stringify(scores));
}

function drawLeaderboard() {
    let scores = JSON.parse(localStorage.getItem(LEADERBOARD_KEY) || "[]");
    ctx.fillStyle = 'white'; ctx.textAlign = 'center'; ctx.font = '16px Noto Sans TC';
    ctx.fillText("--- æ­·å²æœ€é«˜åˆ† ---", GAME_WIDTH/2, 530);
    scores.forEach((s, i) => {
        ctx.fillStyle = '#bdc3c7'; ctx.fillText(`${i+1}. ${s.name} : ${s.score}`, GAME_WIDTH/2, 555 + i*20);
    });
}

function loop() {
    update(); draw(); requestAnimationFrame(loop);
}

function resize() {
    let scale = Math.min(window.innerWidth / GAME_WIDTH, window.innerHeight / GAME_HEIGHT);
    canvas.style.width = (GAME_WIDTH * scale) + 'px';
    canvas.style.height = (GAME_HEIGHT * scale) + 'px';
}
window.addEventListener('resize', resize);
resize();
loop();
</script>
</body>
</html>
