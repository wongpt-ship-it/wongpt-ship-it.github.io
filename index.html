<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ËÖ¶ÂäõÂ§ß‰∫ÇÈ¨•ÔºöÈõô‰∫∫Â•ßÊï∏Á´∂ÊäÄÂ†¥</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Noto+Sans+TC:wght@700&display=swap');

        body {
            margin: 0;
            padding: 0;
            background-color: #2c3e50;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            font-family: 'Noto Sans TC', sans-serif;
            color: white;
            user-select: none;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 30px rgba(0,0,0,0.6);
            border: 4px solid #f1c40f;
            border-radius: 8px;
            background-color: #34495e;
        }

        canvas {
            display: block;
        }

        .mobile-warning {
            display: none;
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            color: white;
            z-index: 999;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 20px;
            font-size: 1.2rem;
        }

        @media (hover: none) and (pointer: coarse) {
            .mobile-warning { display: flex; }
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div class="mobile-warning">Ë´ã‰ΩøÁî®ÈõªËÖ¶ÈçµÁõ§ÈÄ≤Ë°åÈõô‰∫∫Â∞çÊà∞‰ª•Áç≤ÂæóÊúÄ‰Ω≥È´îÈ©ó„ÄÇ</div>
</div>

<script>
/**
 * ËÖ¶ÂäõÂ§ß‰∫ÇÈ¨• v2.5
 * ‰øÆÊ≠£Ôºö‰∏âËßíÂΩ¢Êï∏Èáè<15„ÄÅÁ†≤Âè∞Â∞ÑÊìäÈªû„ÄÅÈóúÂç°Âæ™Áí∞Ê©üÂà∂„ÄÅUIÈÇäÊ°Ü
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// --- ÂÖ®Â±ÄËÆäÊï∏ ---
const GAME_WIDTH = 800;
const GAME_HEIGHT = 600;

const STATE = {
    MENU: 0,
    INSTRUCTION: 1,
    PLAYING: 2,
    ROUND_END: 3,
    GAME_OVER: 4
};

let currentState = STATE.MENU;
let frameCount = 0;
let totalTime = 60;
let timeRemaining = 0;

// Áé©ÂÆ∂ÈÖçÁΩÆ
const p1 = { score: 0, color: '#3498db', name: 'Player 1', emoji: 'ü§ñ', lastKey: null, lastKeyTime: 0, dash: false, stun: 0 };
const p2 = { score: 0, color: '#e74c3c', name: 'Player 2', emoji: 'ü¶ñ', lastKey: null, lastKeyTime: 0, dash: false, stun: 0 };

const keys = {};
let currentMode = null;
let roundWinner = null;
let roundInstruction = "";

// ÈóúÂç°Ê±† (Áî®Êñº‰øùË≠â‰∏çÈáçË§á‰∏îÈÅçÊ≠∑ÊâÄÊúâÊ®°Âºè)
let modeDeck = [];

const LEADERBOARD_KEY = 'math_battle_ranking_v2';

// --- Â∑•ÂÖ∑ÂáΩÊï∏ ---

function randomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

function rectIntersect(x1, y1, w1, h1, x2, y2, w2, h2) {
    return x2 < x1 + w1 && x2 + w2 > x1 && y2 < y1 + h1 && y2 + h2 > y1;
}

function circleIntersect(x1, y1, r1, x2, y2, r2) {
    let dist = Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2);
    return dist < r1 + r2;
}

function drawEmoji(emoji, x, y, size) {
    ctx.font = `${size}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(emoji, x, y);
}

// --- Ëº∏ÂÖ•ËôïÁêÜ ---
window.addEventListener('keydown', (e) => {
    if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight", "Space"].indexOf(e.code) > -1) {
        e.preventDefault();
    }
    const key = e.key.toLowerCase();
    const now = Date.now();
    let player = null;

    if (['w','a','s','d'].includes(key)) player = p1;
    if (['arrowup','arrowdown','arrowleft','arrowright'].includes(key)) player = p2;

    if (player && player.stun <= 0) {
        if (player.lastKey === key && now - player.lastKeyTime < 300) {
            player.dash = true; 
        }
        player.lastKey = key;
        player.lastKeyTime = now;
    }

    keys[key] = true;
});

window.addEventListener('keyup', (e) => {
    const key = e.key.toLowerCase();
    keys[key] = false;
    if (['w','a','s','d'].includes(key)) p1.dash = false;
    if (['arrowup','arrowdown','arrowleft','arrowright'].includes(key)) p2.dash = false;
});

// --- È°åÁõÆÁîüÊàêÂô® ---
function generateProblem(forceType = -1) {
    const difficulty = Math.min(1, (60 - totalTime) / 50); 
    let type = forceType !== -1 ? forceType : (difficulty < 0.4 ? 0 : (Math.random() > 0.6 ? 2 : 1));

    let q = "", a = 0, options = [];

    if (type === 0) { // Âä†Ê∏õ
        let max = 10 + Math.floor(difficulty * 40);
        let n1 = randomInt(1, max);
        let n2 = randomInt(1, max);
        if (Math.random() > 0.5) {
            q = `${n1} + ${n2} = ?`;
            a = n1 + n2;
        } else {
            let big = Math.max(n1, n2);
            let small = Math.min(n1, n2);
            q = `${big} - ${small} = ?`;
            a = big - small;
        }
    } else if (type === 1) { // ‰πòÊ≥ï
        let maxMulti = 3 + Math.floor(difficulty * 9); 
        let n1 = randomInt(2, maxMulti);
        let n2 = randomInt(2, maxMulti);
        q = `${n1} √ó ${n2} = ?`;
        a = n1 * n2;
    } else { // Êï∏Âàó
        let start = randomInt(1, 10);
        let step = randomInt(2, 5);
        let idx = randomInt(2, 4); 
        let seq = [];
        for(let i=0; i<5; i++) seq.push(start + i*step);
        a = seq[idx];
        seq[idx] = '?';
        q = seq.join(', ');
    }

    while(options.length < 3) {
        let offset = randomInt(-5, 5);
        if (offset === 0) continue;
        let wrong = a + offset;
        if (wrong < 0) wrong = Math.abs(wrong);
        if (wrong !== a && !options.includes(wrong)) options.push(wrong);
    }
    options.push(a);
    options.sort(() => Math.random() - 0.5);
    return { text: q, answer: a, options: options };
}

// --- ÈÅäÊà≤Ê®°ÂºèÈ°ûÂà• ---
class GameMode {
    constructor() {
        this.winner = null;
        this.problem = generateProblem();
    }
    init() {}
    update() {}
    draw() {}
    checkWin(player) {
        if (!this.winner) {
            this.winner = player;
            player.score += 100;
            setTimeout(() => { if (currentState === STATE.PLAYING) endGameRound(player); }, 500); 
        } else if (this.winner !== player) {
             player.score += 50;
        }
    }
    // Áπ™Ë£ΩÂ∏∂Ê°ÜÁöÑÈÅ∏È†Ö
    drawOptionText(val, x, y, keyHint) {
        // Áï´Â§ñÊ°Ü
        ctx.beginPath();
        ctx.arc(x, y, 35, 0, Math.PI*2);
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fill();
        ctx.lineWidth = 4;
        ctx.strokeStyle = '#f1c40f'; // ÈáëËâ≤ÈÇäÊ°Ü
        ctx.stroke();

        ctx.fillStyle = 'white'; 
        ctx.font = 'bold 30px Arial'; 
        ctx.textAlign = 'center'; 
        ctx.textBaseline = 'middle';
        ctx.fillText(val, x, y + 2); // ÂæÆË™øÂûÇÁõ¥‰ΩçÁΩÆ

        // ÊåâÈçµÊèêÁ§∫
        ctx.fillStyle = '#bdc3c7'; 
        ctx.font = '14px Arial'; 
        ctx.fillText(keyHint, x, y + 55);
    }
}

// Mode 1: ÁÇÆÂè∞Â∞ÑÊìä
class ShooterMode extends GameMode {
    constructor() {
        super();
        this.bullets = [];
        this.targets = []; 
        this.p1Angle = 0; this.p2Angle = 0;
        this.p1Cooldown = 0; this.p2Cooldown = 0;
        this.barrelLen = 45; // Á†≤ÁÆ°Èï∑Â∫¶ (Áî®ÊñºË®àÁÆóÁôºÂ∞ÑÈªû)
    }

    init() {
        this.problem.options.forEach(opt => {
            this.targets.push({
                x: randomInt(100, 700), y: randomInt(50, 250),
                vx: (Math.random() - 0.5) * 4, vy: (Math.random() - 0.5) * 4,
                val: opt, r: 25,
                type: opt === this.problem.answer ? 'correct' : 'wrong'
            });
        });
        this.walls = [{x: 350, y: 300, w: 100, h: 20}, {x: 100, y: 150, w: 20, h: 100}, {x: 680, y: 150, w: 20, h: 100}];
    }

    update() {
        // P1 Control
        if (keys['a']) this.p1Angle -= 0.08;
        if (keys['d']) this.p1Angle += 0.08;
        this.p1Angle = Math.max(-1.5, Math.min(1.5, this.p1Angle));
        
        if (keys['w'] && this.p1Cooldown <= 0) {
            // Ë®àÁÆóÊßçÂè£‰ΩçÁΩÆ (ÁÅ´ÁÆ≠‰∏≠ÂøÉ 100, 550)
            let bx = 100 + Math.sin(this.p1Angle) * this.barrelLen;
            let by = 550 - Math.cos(this.p1Angle) * this.barrelLen;
            this.bullets.push({x: bx, y: by, vx: Math.sin(this.p1Angle)*12, vy: -Math.cos(this.p1Angle)*12, owner: p1, life: 100});
            this.p1Cooldown = 20;
        }

        // P2 Control
        if (keys['arrowleft']) this.p2Angle -= 0.08;
        if (keys['arrowright']) this.p2Angle += 0.08;
        this.p2Angle = Math.max(-1.5, Math.min(1.5, this.p2Angle));
        
        if (keys['arrowup'] && this.p2Cooldown <= 0) {
            let bx = 700 + Math.sin(this.p2Angle) * this.barrelLen;
            let by = 550 - Math.cos(this.p2Angle) * this.barrelLen;
            this.bullets.push({x: bx, y: by, vx: Math.sin(this.p2Angle)*12, vy: -Math.cos(this.p2Angle)*12, owner: p2, life: 100});
            this.p2Cooldown = 20;
        }

        if (this.p1Cooldown > 0) this.p1Cooldown--;
        if (this.p2Cooldown > 0) this.p2Cooldown--;

        // Targets
        this.targets.forEach(t => {
            t.x += t.vx; t.y += t.vy;
            if (t.x < t.r || t.x > GAME_WIDTH - t.r) t.vx *= -1;
            if (t.y < t.r || t.y > 400) t.vy *= -1;
        });

        // Bullets
        for (let i = this.bullets.length - 1; i >= 0; i--) {
            let b = this.bullets[i];
            b.x += b.vx; b.y += b.vy; b.life--;
            if (b.x < 0 || b.x > GAME_WIDTH) b.vx *= -1;
            if (b.y < 0) b.vy *= -1; 
            this.walls.forEach(w => { if (rectIntersect(b.x, b.y, 5, 5, w.x, w.y, w.w, w.h)) b.vy *= -1; });

            for (let t of this.targets) {
                if (circleIntersect(b.x, b.y, 5, t.x, t.y, t.r)) {
                    if (t.type === 'correct') this.checkWin(b.owner);
                    else b.life = 0; 
                    this.bullets.splice(i, 1);
                    break;
                }
            }
            if (b.life <= 0 || b.y > 600) this.bullets.splice(i, 1);
        }
    }

    draw() {
        ctx.fillStyle = 'white';
        ctx.font = '30px Noto Sans TC';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'alphabetic';
        ctx.fillText(`Â∞ÑÊìäÊ≠£Á¢∫Á≠îÊ°à: ${this.problem.text}`, GAME_WIDTH/2, 50);

        this.targets.forEach(t => {
            ctx.fillStyle = '#ecf0f1';
            ctx.beginPath(); ctx.arc(t.x, t.y, t.r, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#2c3e50'; ctx.font = 'bold 20px Arial'; ctx.textBaseline = 'middle'; ctx.fillText(t.val, t.x, t.y);
        });

        ctx.fillStyle = '#7f8c8d';
        this.walls.forEach(w => { ctx.fillRect(w.x, w.y, w.w, w.h); drawEmoji('üß±', w.x + w.w/2, w.y + w.h/2, 20); });

        // Draw Turrets
        const drawTurret = (x, angle, emoji) => {
            ctx.save(); ctx.translate(x, 550); ctx.rotate(angle);
            // ÈÄôË£°ÂæÆË™øÁÅ´ÁÆ≠‰ΩçÁΩÆÔºåËÆìÊóãËΩâ‰∏≠ÂøÉÂú®ÁÅ´ÁÆ≠Â∫ïÈÉ®ÔºåÈ†ÇÁ´ØÂú® (0, -45) Â∑¶Âè≥
            drawEmoji('üöÄ', 0, -20, 50); 
            ctx.restore();
            drawEmoji(emoji, x, 580, 30);
        };
        drawTurret(100, this.p1Angle, p1.emoji);
        drawTurret(700, this.p2Angle, p2.emoji);

        this.bullets.forEach(b => drawEmoji('üîπ', b.x, b.y, 15));
    }
}

// Mode 2: Êï∏Âπæ‰ΩïÂúñÂΩ¢ (‰øÆÊ≠£Êï∏ÈáèÈôêÂà∂)
class GeometryMode extends GameMode {
    constructor() {
        super();
        this.problem.text = "Âúñ‰∏≠ÂÖ±ÊúâÂ§öÂ∞ëÂÄã‰∏âËßíÂΩ¢Ôºü";
        
        let segments, layers, count;
        // Âö¥Ê†ºÈôêÂà∂Á∏ΩÊï∏Âú® 15 ‰ª•‰∏ã
        // ÂÖ¨Âºè: (segments * (segments+1) / 2) * layers
        do {
            segments = randomInt(2, 4); // Â∫ïÈÇäÊÆµÊï∏ÈôêÂà∂ 2-4
            layers = randomInt(1, 2);   // Â±§Êï∏ÈôêÂà∂ 1-2
            count = (segments * (segments + 1) / 2) * layers;
        } while (count > 15);

        this.problem.answer = count;
        this.structure = { segments: segments, layers: layers };

        // ÈÅ∏È†ÖÁîüÊàê
        this.options = { 'Up': 0, 'Down': 0, 'Left': 0, 'Right': 0 };
        let keys = Object.keys(this.options);
        let correctKey = keys[randomInt(0, 3)];
        
        keys.forEach(k => {
            if (k === correctKey) this.options[k] = count;
            else {
                let n = count + randomInt(-3, 3);
                while (n === count || n <= 0) n = count + randomInt(-4, 4);
                this.options[k] = n;
            }
        });
    }

    update() {
        if (keys['w']) this.checkAnswer(p1, 'Up');
        else if (keys['s']) this.checkAnswer(p1, 'Down');
        else if (keys['a']) this.checkAnswer(p1, 'Left');
        else if (keys['d']) this.checkAnswer(p1, 'Right');

        if (keys['arrowup']) this.checkAnswer(p2, 'Up');
        else if (keys['arrowdown']) this.checkAnswer(p2, 'Down');
        else if (keys['arrowleft']) this.checkAnswer(p2, 'Left');
        else if (keys['arrowright']) this.checkAnswer(p2, 'Right');
    }

    checkAnswer(player, dir) {
        if (this.winner === player) return;
        if (player.lock) return;

        if (this.options[dir] === this.problem.answer) {
            this.checkWin(player);
        } else {
            player.score = Math.max(0, player.score - 10);
            player.lock = true;
            setTimeout(() => player.lock = false, 500);
        }
    }

    draw() {
        ctx.fillStyle = 'white';
        ctx.font = '30px Noto Sans TC';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'alphabetic';
        ctx.fillText(this.problem.text, GAME_WIDTH/2, 60);

        const topX = GAME_WIDTH / 2;
        const topY = 150;
        const baseY = 450;
        const baseWidth = 300;
        const leftX = topX - baseWidth / 2;
        const rightX = topX + baseWidth / 2;

        ctx.strokeStyle = '#f1c40f';
        ctx.lineWidth = 4;
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';

        // 1. Â§ñÊ°Ü
        ctx.beginPath();
        ctx.moveTo(topX, topY);
        ctx.lineTo(leftX, baseY);
        ctx.lineTo(rightX, baseY);
        ctx.closePath();
        ctx.stroke();

        // 2. ÊîæÂ∞ÑÁ∑ö
        let segs = this.structure.segments;
        for (let i = 1; i < segs; i++) {
            let ratio = i / segs;
            let targetX = leftX + (baseWidth * ratio);
            ctx.beginPath();
            ctx.moveTo(topX, topY);
            ctx.lineTo(targetX, baseY);
            ctx.stroke();
        }

        // 3. Ê©´ÂàáÁ∑ö
        let lays = this.structure.layers;
        for (let i = 1; i < lays; i++) {
            let ratio = i / lays;
            let ly = topY + (baseY - topY) * ratio;
            let lx = topX - (baseWidth / 2) * ratio;
            let rx = topX + (baseWidth / 2) * ratio;
            ctx.beginPath();
            ctx.moveTo(lx, ly);
            ctx.lineTo(rx, ly);
            ctx.stroke();
        }

        // Áπ™Ë£ΩÂ∏∂Ê°ÜÁöÑÈÅ∏È†Ö
        this.drawOptionText(this.options.Up, GAME_WIDTH/2, 110, '‚Üë W');
        this.drawOptionText(this.options.Down, GAME_WIDTH/2, 550, '‚Üì S');
        this.drawOptionText(this.options.Left, 100, 300, '‚Üê A');
        this.drawOptionText(this.options.Right, 700, 300, '‚Üí D');
    }
}

// Mode 3: Êï∏Á©çÊú® (È°ØÁ§∫‰øÆÂæ© + Êï∏ÈáèÈôêÂà∂)
class CubeMode extends GeometryMode {
    constructor() {
        super();
        this.problem.text = "Êï∏Êï∏ÊúâÂ§öÂ∞ëÂÄãÁ©çÊú®Ôºü";
        this.cubes = [];
        
        let totalCubes = 0;
        let attempts = 0;

        while (true) {
            this.cubes = [];
            totalCubes = 0;
            // ‰ΩøÁî® 3x3 Á∂≤Ê†º
            for(let x=0; x<3; x++) {
                for(let y=0; y<3; y++) {
                    let h = randomInt(0, 3);
                    if(x===1 && y===1 && h===0) h=1; 
                    for(let z=0; z<h; z++) {
                        this.cubes.push({gx: x, gy: y, gz: z});
                    }
                    totalCubes += h;
                }
            }
            if (totalCubes > 1 && totalCubes <= 15) break; 
            attempts++;
            if (attempts > 100) break;
        }
        
        this.problem.answer = totalCubes;
        
        this.options = { 'Up': 0, 'Down': 0, 'Left': 0, 'Right': 0 };
        let keys = Object.keys(this.options);
        let correctKey = keys[randomInt(0, 3)];
        keys.forEach(k => {
            if (k === correctKey) this.options[k] = totalCubes;
            else {
                let n = totalCubes + randomInt(-3, 3);
                while (n === totalCubes || n <= 0) n = totalCubes + randomInt(-4, 4);
                this.options[k] = n;
            }
        });
    }

    draw() {
        ctx.fillStyle = 'white';
        ctx.font = '30px Noto Sans TC';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'alphabetic';
        ctx.fillText(this.problem.text, GAME_WIDTH/2, 60);

        let originX = GAME_WIDTH / 2;
        let originY = 280;
        let size = 50;

        // Áï´ÂÆ∂ÊºîÁÆóÊ≥ïÊéíÂ∫è
        this.cubes.sort((a, b) => {
            let depthA = a.gx + a.gy;
            let depthB = b.gx + b.gy;
            if (depthA !== depthB) return depthA - depthB;
            return a.gz - b.gz;
        });

        this.cubes.forEach(c => {
            let x = (c.gx - c.gy) * size + originX;
            let y = (c.gx + c.gy) * size * 0.5 - (c.gz * size) + originY;
            this.drawCube(x, y, size);
        });

        this.drawOptionText(this.options.Up, GAME_WIDTH/2, 110, '‚Üë W');
        this.drawOptionText(this.options.Down, GAME_WIDTH/2, 550, '‚Üì S');
        this.drawOptionText(this.options.Left, 100, 300, '‚Üê A');
        this.drawOptionText(this.options.Right, 700, 300, '‚Üí D');
    }

    drawCube(x, y, size) {
        ctx.lineWidth = 1;
        ctx.strokeStyle = '#2c3e50';
        // Top
        ctx.fillStyle = '#e74c3c'; ctx.beginPath();
        ctx.moveTo(x, y - size); ctx.lineTo(x + size, y - size * 1.5);
        ctx.lineTo(x, y - size * 2); ctx.lineTo(x - size, y - size * 1.5);
        ctx.fill(); ctx.stroke();
        // Right
        ctx.fillStyle = '#c0392b'; ctx.beginPath();
        ctx.moveTo(x, y - size); ctx.lineTo(x + size, y - size * 1.5);
        ctx.lineTo(x + size, y - size * 0.5); ctx.lineTo(x, y);
        ctx.fill(); ctx.stroke();
        // Left
        ctx.fillStyle = '#e67e22'; ctx.beginPath();
        ctx.moveTo(x, y - size); ctx.lineTo(x - size, y - size * 1.5);
        ctx.lineTo(x - size, y - size * 0.5); ctx.lineTo(x, y);
        ctx.fill(); ctx.stroke();
    }
}

// Mode 4: Â•™ÂØ∂ËøΩÈÄê
class ChaseMode extends GameMode {
    constructor() {
        super();
        this.problem = generateProblem(); 
        this.problem.text = "ÁÆóÂá∫Á≠îÊ°à‰∏¶Êê∂Â•™ÔºÅ" + this.problem.text;
        
        this.holder = null;
        this.holdTime = 0;
        this.targetTime = 180;
        
        this.items = [];
        let answers = this.problem.options.slice(0, 3);
        answers.forEach((ans, i) => {
            this.items.push({
                x: randomInt(100, 700),
                y: randomInt(100, 500),
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2,
                val: ans,
                isCorrect: (ans === this.problem.answer)
            });
        });

        this.p1Pos = { x: 150, y: 300, cooldown: 0 };
        this.p2Pos = { x: 650, y: 300, cooldown: 0 };
    }

    update() {
        this.movePlayer(this.p1Pos, 'w', 's', 'a', 'd', p1);
        this.movePlayer(this.p2Pos, 'arrowup', 'arrowdown', 'arrowleft', 'arrowright', p2);

        this.items.forEach(item => {
            if (this.holder && item.isCorrect) {
                 let pos = this.holder === p1 ? this.p1Pos : this.p2Pos;
                 item.x = pos.x;
                 item.y = pos.y - 45;
            } else {
                item.x += item.vx; item.y += item.vy;
                if(item.x < 30 || item.x > GAME_WIDTH-30) item.vx *= -1;
                if(item.y < 30 || item.y > GAME_HEIGHT-30) item.vy *= -1;
            }
        });

        if (!this.holder) {
            this.checkPickUp(p1, this.p1Pos);
            this.checkPickUp(p2, this.p2Pos);
        } else {
            this.holdTime++;
            if (this.holdTime >= this.targetTime) this.checkWin(this.holder);
        }

        this.checkCollisions();
        
        if(p1.stun > 0) p1.stun--;
        if(p2.stun > 0) p2.stun--;
    }

    checkPickUp(player, pos) {
        if (player.stun > 0) return;
        for (let item of this.items) {
            if (circleIntersect(pos.x, pos.y, 30, item.x, item.y, 30)) {
                if (item.isCorrect) {
                    this.holder = player;
                } else {
                    player.stun = 60; 
                    pos.x -= item.vx * 10;
                }
            }
        }
    }

    movePlayer(pos, u, d, l, r, playerRef) {
        if (playerRef.stun > 0) return; 
        let speed = 5;
        if (this.holder === playerRef) speed = 4;
        if (playerRef.dash && pos.cooldown <= 0) { speed = 12; pos.cooldown = 15; }
        if (pos.cooldown > 0) { pos.cooldown--; speed = 12; }
        if (keys[u]) pos.y -= speed;
        if (keys[d]) pos.y += speed;
        if (keys[l]) pos.x -= speed;
        if (keys[r]) pos.x += speed;
        pos.x = Math.max(30, Math.min(GAME_WIDTH - 30, pos.x));
        pos.y = Math.max(30, Math.min(GAME_HEIGHT - 30, pos.y));
    }

    checkCollisions() {
        if (circleIntersect(this.p1Pos.x, this.p1Pos.y, 30, this.p2Pos.x, this.p2Pos.y, 30)) {
            let p1Dashing = p1.dash; let p2Dashing = p2.dash;
            if (p1Dashing && this.holder === p2) { this.holder = null; this.holdTime = 0; } 
            else if (p2Dashing && this.holder === p1) { this.holder = null; this.holdTime = 0; }
        }
    }

    draw() {
        ctx.fillStyle = 'white';
        ctx.font = '30px Noto Sans TC';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'alphabetic';
        let probPart = this.problem.text.split("ÔºÅ")[1] || this.problem.text;
        ctx.fillText(`ÁÆóÂá∫ ${probPart} ‰∏¶Êê∂Â•™ÔºÅ`, GAME_WIDTH/2, 50);

        const drawPlayer = (p, pos) => {
            drawEmoji(p.emoji, pos.x, pos.y, 50);
            if (p.stun > 0) drawEmoji('üí´', pos.x, pos.y - 30, 30);
            if (p.dash) drawEmoji('üí®', pos.x - 20, pos.y, 30);
        };
        drawPlayer(p1, this.p1Pos);
        drawPlayer(p2, this.p2Pos);

        this.items.forEach(item => {
            ctx.beginPath(); ctx.arc(item.x, item.y, 30, 0, Math.PI*2);
            ctx.fillStyle = '#f39c12'; ctx.fill();
            ctx.strokeStyle = '#ecf0f1'; ctx.lineWidth = 3; ctx.stroke();
            ctx.fillStyle = 'white'; ctx.font = 'bold 24px Arial'; ctx.textBaseline = 'middle';
            ctx.fillText(item.val, item.x, item.y);
        });

        if (this.holder) {
            ctx.fillStyle = this.holder.color;
            let w = (this.holdTime / this.targetTime) * 300;
            ctx.fillRect(GAME_WIDTH/2 - 150, 80, w, 20);
            ctx.strokeStyle = 'white'; ctx.lineWidth = 2;
            ctx.strokeRect(GAME_WIDTH/2 - 150, 80, 300, 20);
        }
    }
}

// Mode 5: Êï∏Â≠óÈõ®
class RainMode extends GameMode {
    constructor() {
        super();
        this.items = []; this.spawnTimer = 0;
        this.p1X = 200; this.p2X = 600;
        if(this.problem.text.includes(',')) this.problem = generateProblem(0); 
    }

    update() {
        if (keys['a']) this.p1X -= 8;
        if (keys['d']) this.p1X += 8;
        if (keys['arrowleft']) this.p2X -= 8;
        if (keys['arrowright']) this.p2X += 8;

        this.p1X = Math.max(30, Math.min(GAME_WIDTH - 30, this.p1X));
        this.p2X = Math.max(30, Math.min(GAME_WIDTH - 30, this.p2X));

        this.spawnTimer++;
        if (this.spawnTimer > 40) {
            this.spawnTimer = 0;
            let r = Math.random();
            let type = 'wrong'; let val = 0;
            if (r > 0.7) { type = 'correct'; val = this.problem.answer; }
            else if (r < 0.2) { type = 'bomb'; val = ''; }
            else { val = this.problem.answer + randomInt(1, 10) * (Math.random()>0.5?1:-1); }

            this.items.push({ x: randomInt(30, GAME_WIDTH - 30), y: -30, type: type, val: val, speed: 3 + Math.random() * 3 });
        }

        for (let i = this.items.length - 1; i >= 0; i--) {
            let item = this.items[i]; item.y += item.speed;
            if (Math.abs(item.x - this.p1X) < 40 && Math.abs(item.y - 550) < 40) { this.handleCatch(p1, item, i); continue; }
            if (Math.abs(item.x - this.p2X) < 40 && Math.abs(item.y - 550) < 40) { this.handleCatch(p2, item, i); continue; }
            if (item.y > GAME_HEIGHT) this.items.splice(i, 1);
        }
    }

    handleCatch(player, item, index) {
        this.items.splice(index, 1);
        if (item.type === 'correct') this.checkWin(player);
        else if (item.type === 'bomb') player.score = Math.max(0, player.score - 50);
        else player.score = Math.max(0, player.score - 10);
    }

    draw() {
        ctx.fillStyle = 'white'; ctx.font = '30px Noto Sans TC'; ctx.textAlign = 'center'; ctx.textBaseline = 'alphabetic';
        ctx.fillText(`Êé•‰ΩèÊ≠£Á¢∫Á≠îÊ°à: ${this.problem.text}`, GAME_WIDTH/2, 50);
        drawEmoji(p1.emoji, this.p1X, 550, 60);
        drawEmoji(p2.emoji, this.p2X, 550, 60);

        this.items.forEach(item => {
            if (item.type === 'bomb') drawEmoji('üí£', item.x, item.y, 40);
            else {
                ctx.fillStyle = item.type === 'correct' ? '#f1c40f' : '#ecf0f1';
                ctx.beginPath(); ctx.arc(item.x, item.y, 25, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = 'black'; ctx.font = '20px Arial'; ctx.textBaseline = 'middle'; ctx.fillText(item.val, item.x, item.y);
            }
        });
    }
}

// --- ÊµÅÁ®ãÊéßÂà∂ ---

function startNewGame() {
    p1.score = 0; p2.score = 0;
    p1.stun = 0; p2.stun = 0;
    totalTime = 60;
    modeDeck = []; // ÈáçÁΩÆÈóúÂç°Ê±†
    currentState = STATE.MENU;
}

function selectNextMode() {
    // Ê¥óÁâåÊ©üÂà∂ (Shuffle Bag)
    // Â¶ÇÊûúÊ±†Â≠êÁ©∫‰∫ÜÔºåÈáçÊñ∞Â°´Êªø
    if (modeDeck.length === 0) {
        modeDeck = [0, 1, 2, 3, 4];
        // Shuffle
        for (let i = modeDeck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [modeDeck[i], modeDeck[j]] = [modeDeck[j], modeDeck[i]];
        }
    }
    
    // ÂèñÂá∫‰∏ÄÂºµÁâå
    const nextIndex = modeDeck.pop();
    const modes = [ShooterMode, GeometryMode, CubeMode, ChaseMode, RainMode];
    
    currentMode = new modes[nextIndex]();
    currentMode.init();
    
    const instructions = ["Â∞ÑÊìäÊ≠£Á¢∫Á≠îÊ°àÔºÅ", "Êï∏Êï∏‰∏âËßíÂΩ¢ÔºÅ", "Êï∏Êï∏Á©çÊú®ÔºÅ", "ÁÆóÂá∫Á≠îÊ°à‰∏¶Êê∂Â•™ÔºÅ", "Êé•‰ΩèÊ≠£Á¢∫Á≠îÊ°àÔºÅ"];
    roundInstruction = instructions[nextIndex];
    
    currentState = STATE.INSTRUCTION;
    timeRemaining = 120; 
}

function endGameRound(winner) {
    roundWinner = winner;
    currentState = STATE.ROUND_END;
    timeRemaining = 60; 
}

function update() {
    frameCount++;
    if (currentState === STATE.MENU) {
        if (keys[' ']) { totalTime = 60; p1.score = 0; p2.score = 0; selectNextMode(); }
    } else if (currentState === STATE.INSTRUCTION) {
        timeRemaining--;
        if (timeRemaining <= 0) currentState = STATE.PLAYING;
    } else if (currentState === STATE.PLAYING) {
        if (frameCount % 60 === 0) totalTime--;
        if (totalTime <= 0) { saveScore(); currentState = STATE.GAME_OVER; }
        currentMode.update();
    } else if (currentState === STATE.ROUND_END) {
        timeRemaining--;
        if (timeRemaining <= 0) selectNextMode();
    } else if (currentState === STATE.GAME_OVER) {
        if (keys[' ']) startNewGame();
    }
}

function draw() {
    ctx.fillStyle = '#2c3e50';
    ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

    if (currentState === STATE.MENU) {
        ctx.fillStyle = 'white'; ctx.textAlign = 'center'; ctx.textBaseline = 'alphabetic';
        ctx.font = '50px "Press Start 2P"'; ctx.fillText("ËÖ¶ÂäõÂ§ß‰∫ÇÈ¨•", GAME_WIDTH/2, 180);
        ctx.font = '24px Noto Sans TC'; ctx.fillText("Êåâ [Á©∫ÁôΩÈçµ] ÈñãÂßãÈÅäÊà≤", GAME_WIDTH/2, 280);
        
        ctx.textAlign = 'left';
        ctx.fillStyle = p1.color; ctx.fillText(`${p1.emoji} Áé©ÂÆ∂ 1: WASD`, 180, 380);
        ctx.fillStyle = p2.color; ctx.fillText(`${p2.emoji} Áé©ÂÆ∂ 2: ÊñπÂêëÈçµ`, 480, 380);
        
        drawLeaderboard();

    } else if (currentState === STATE.INSTRUCTION) {
        ctx.fillStyle = '#f1c40f'; ctx.font = 'bold 60px Noto Sans TC'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(roundInstruction, GAME_WIDTH/2, GAME_HEIGHT/2);
        
    } else if (currentState === STATE.PLAYING) {
        currentMode.draw();
        
        // HUD
        ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(0, 0, GAME_WIDTH, 40); 
        ctx.textAlign = 'center'; ctx.textBaseline = 'alphabetic'; ctx.fillStyle = totalTime < 10 ? '#e74c3c' : 'white';
        ctx.font = '20px "Press Start 2P"'; ctx.fillText(`TIME: ${totalTime}`, GAME_WIDTH/2, 28);

        ctx.textAlign = 'left'; ctx.fillStyle = p1.color; ctx.fillText(`${p1.emoji} ${p1.score}`, 20, 28);
        ctx.textAlign = 'right'; ctx.fillStyle = p2.color; ctx.fillText(`${p2.score} ${p2.emoji}`, GAME_WIDTH - 20, 28);

    } else if (currentState === STATE.ROUND_END) {
        currentMode.draw();
        ctx.fillStyle = 'rgba(0,0,0,0.7)'; ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
        ctx.fillStyle = 'white'; ctx.font = '60px Noto Sans TC'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        if (roundWinner) {
            ctx.fillText(`${roundWinner.emoji} Áç≤Âãù!`, GAME_WIDTH/2, GAME_HEIGHT/2);
            ctx.font = '30px Arial'; ctx.fillStyle = '#f1c40f'; ctx.fillText("+100 ÂàÜ", GAME_WIDTH/2, GAME_HEIGHT/2 + 50);
        } else ctx.fillText("ÊôÇÈñìÂà∞!", GAME_WIDTH/2, GAME_HEIGHT/2);

    } else if (currentState === STATE.GAME_OVER) {
        ctx.fillStyle = 'white'; ctx.font = '50px "Press Start 2P"'; ctx.textAlign = 'center'; ctx.textBaseline = 'alphabetic';
        ctx.fillText("GAME OVER", GAME_WIDTH/2, 120);
        
        ctx.font = '40px Noto Sans TC';
        ctx.fillStyle = p1.color; ctx.fillText(`P1: ${p1.score}`, GAME_WIDTH/2, 220);
        ctx.fillStyle = p2.color; ctx.fillText(`P2: ${p2.score}`, GAME_WIDTH/2, 280);

        let wText = p1.score > p2.score ? "Player 1 ÂãùÂà©!" : (p2.score > p1.score ? "Player 2 ÂãùÂà©!" : "Âπ≥Êâã!");
        ctx.fillStyle = '#f1c40f'; ctx.font = 'bold 50px Noto Sans TC'; ctx.fillText(wText, GAME_WIDTH/2, 380);
        ctx.fillStyle = 'white'; ctx.font = '20px Noto Sans TC'; ctx.fillText("Êåâ [Á©∫ÁôΩÈçµ] ÈáçÊñ∞ÈñãÂßã", GAME_WIDTH/2, 500);
    }
}

function saveScore() {
    let scores = JSON.parse(localStorage.getItem(LEADERBOARD_KEY) || "[]");
    if(p1.score > 0) scores.push({name: "P1", score: p1.score});
    if(p2.score > 0) scores.push({name: "P2", score: p2.score});
    scores.sort((a, b) => b.score - a.score);
    if(scores.length > 5) scores = scores.slice(0, 5);
    localStorage.setItem(LEADERBOARD_KEY, JSON.stringify(scores));
}

function drawLeaderboard() {
    let scores = JSON.parse(localStorage.getItem(LEADERBOARD_KEY) || "[]");
    ctx.fillStyle = 'white'; ctx.textAlign = 'center'; ctx.font = '16px Noto Sans TC'; ctx.textBaseline = 'alphabetic';
    ctx.fillText("--- Ê≠∑Âè≤ÊúÄÈ´òÂàÜ ---", GAME_WIDTH/2, 530);
    scores.forEach((s, i) => {
        ctx.fillStyle = '#bdc3c7'; ctx.fillText(`${i+1}. ${s.name} : ${s.score}`, GAME_WIDTH/2, 555 + i*20);
    });
}

function loop() {
    update(); draw(); requestAnimationFrame(loop);
}

function resize() {
    let scale = Math.min(window.innerWidth / GAME_WIDTH, window.innerHeight / GAME_HEIGHT);
    canvas.style.width = (GAME_WIDTH * scale) + 'px';
    canvas.style.height = (GAME_HEIGHT * scale) + 'px';
}
window.addEventListener('resize', resize);
resize();
loop();
</script>
</body>
</html>
